{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-tinycore","title":"What is tinyCore?","text":"<p>tinyCore is an engineering learning platform based around a truly open-source (open-knowledge) microcontroller designed to help educate individuals on the world of advanced embedded systems. tinyCore\u2019s mission is to bridge the gap between undergrad and industry, equipping young professionals with the resources they need to build their portfolio and bring their ideas to life. </p> <p> Key Features:</p> <ul> <li>Wi-Fi and Bluetooth</li> <li>USB-C Charging and Programming</li> <li>Integrated Motion Tracking</li> <li>Built-in SD Card</li> <li>Arduino IDE and CircuitPython </li> </ul> <p>Start Building!</p>"},{"location":"#how-to-get-involved","title":"How to Get Involved:","text":"<p>Whether you're a seasoned engineer or a curious beginner, there's a place for you in the tinyCommunity. Follow our progress, contribute to our projects, and be part of our learning journey!</p>"},{"location":"#join-the-discord","title":"Join the Discord","text":"<p>Our Discord server provides weekly office hours, community hackathons, project showcases, and technical support. We'd love to see you there.</p> <p>Stay updated with our latest developments and industry insights by following us on LinkedIn and BlueSky.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>All contributions are welcome. Start by forking our repository and checking out our contribution guidelines. </p> <p>Not into coding? Help improve our documentation, share your project builds, or assist others in our Discord community.</p>"},{"location":"#share-your-thoughts","title":"Share Your Thoughts","text":"<p>Your feedback is important to us! </p> <p>Share feature requests and bug reports through GitHub Issues, or reach out directly at support@mr.industries. </p> <p>Our team reviews all suggestions and typically responds within 24 hours.</p>"},{"location":"#about-the-team","title":"About the Team:","text":"<p>Created by best friends, Geoff McIntyre and Aiden Reeves, tinyCore emerges from a shared vision to bridge the gap between academic engineering and industry practice.</p> <p>As graduates from CU Boulder and Colorado School of Mines respectively, they have experienced firsthand the challenges new engineers face: entry-level positions demanding years of experience, and career-changers struggling to enter the field without clear pathways.</p> <p>Together, they founded MR. INDUSTRIES (pronounced \"Mister\") guided by three core principles:</p> <p></p> <p>Aiden (left) and Geoff (right) at Clear Creek Makerspace</p>"},{"location":"#integrity-excellence-and-progress","title":"Integrity, Excellence, and Progress.","text":"<p>By building in the open and putting humans first, MR.INDUSTRIES is making professional embedded development accessible to everyone.</p>"},{"location":"#our-amazing-sponsors","title":"Our Amazing Sponsors","text":"<p>The tinyCore project thrives thanks to the generous support of our manufacturing and development partner:</p> <p></p> <p>PCBWay provides exceptional PCB manufacturing services and has been instrumental in bringing tinyCore to life through their reliable prototyping capabilities.</p>"},{"location":"#want-to-support-us","title":"Want to support us?","text":"<p>Help us advance open-source hardware development by supporting the project. Consider becoming a GitHub sponsor to help fund ongoing development and maintenance. You can also purchase our board! For bulk orders and custom implementations, reach out to our commercial support team at support@mr.industries.</p>  \ud83d\udcab  Monthly subscriptions through GitHub Sponsors or PCBWay directly fund new feature development and community resources. Supporters receive priority support, custom enclosure designs, and early access to new features. Together, we're making advanced microcontrollers accessible to everyone."},{"location":"#resources","title":"Resources:","text":"<p>FAQ</p> <p>User Projects</p>"},{"location":"_templates/_blog/","title":"Weeknotes","text":""},{"location":"_templates/_changelog/","title":"changelog","text":""},{"location":"_templates/_changelog/#general","title":"General","text":""},{"location":"_templates/_changelog/#blog","title":"Blog","text":""},{"location":"_templates/_changelog/#meta","title":"Meta","text":""},{"location":"_templates/_changelog/#obsidian","title":"Obsidian","text":""},{"location":"_templates/_changelog/#social","title":"Social","text":""},{"location":"_templates/_changelog/#minifier","title":"Minifier","text":""},{"location":"_templates/_changelog/#debugger","title":"Debugger","text":"<p>[!note] Legend \u274e - added \u2705 - fixed \u267b\ufe0f - changed \ud83d\udeab - removed</p>"},{"location":"_templates/_post/","title":"None","text":""},{"location":"_templates/_post/#changelog","title":"Changelog","text":""},{"location":"_templates/_post/#general","title":"General","text":""},{"location":"_templates/_post/#blog","title":"Blog","text":""},{"location":"_templates/_post/#meta","title":"Meta","text":""},{"location":"_templates/_post/#obsidian","title":"Obsidian","text":""},{"location":"_templates/_post/#social","title":"Social","text":""},{"location":"_templates/_post/#minifier","title":"Minifier","text":""},{"location":"_templates/_post/#debugger","title":"Debugger","text":"<p>[!faq] Legend \u274e - added \u2705 - fixed \u267b\ufe0f - changed \ud83d\udeab - removed</p>"},{"location":"advanced/","title":"Advanced Concepts","text":""},{"location":"advanced/#this-zone-is-under-construction","title":"THIS ZONE IS UNDER CONSTRUCTION","text":""},{"location":"advanced/How%20to%20Create%20Custom%20Arduino%20Board%20Libraries%20for%20E%2019f67bb8fd9481198d53e2e814bc54dd/","title":"How to Create Custom Arduino Board Libraries for ESP32 - Instructable","text":"<p>Created: February 18, 2025 10:25 PM</p>"},{"location":"advanced/How%20to%20Make%20a%20Microcontroller%20-%20Instructable%2019f67bb8fd94819d9f5defc5339fa4fe/","title":"How to Make a Microcontroller - Instructable","text":"<p>Created: February 18, 2025 10:25 PM</p> <p>Background:</p> <p>Ever since I was a small child, I've wanted to develop the skills necessary to design my own circuit boards. I didn't really know how they worked or what was going on, but I knew they were cool. 7 years later, as a senior in electrical engineering, I finally have those tools and I'd like to share some of them with you. </p> <p>If you've ever wanted to make your own Arduino, done lots of solderless breadboarding, and want to create something more professional, maybe even your own product, this tutorial is for you. </p> <p>What is a microcontroller? </p> <p>First we should actually go over what a microcontroller is. Most people know about circuit boards but they don't understand how they work. Microcontrollers are the brains of these boards. They are the tiny logic modules that contain useful built in functions, like analog voltage measurements (inputs and outputs) and serial communication, not to be confused with cereal communication, when you cry into your froot loops, although if you get into Engineering this may be a more common occurrence than you'd like.</p> <p>Serial communication is how two different circuits talk to each other. There are tons of different protocols, wiring configurations, etc, but essentially it's the external language your microcontroller can use to communicate with other chips. This could be I2C (usually pronounced Eye-squared-see) SPI (pronounced \u201cSpy\u201d) UART or CAN. </p> <p>You can learn all about serial communication in this Instructable.</p> <p>Overall, these microchips are extremely useful, however they are usually small, hard to use with a breadboard, and require what we call a \u201cbreakout\u201d board. If we connect a chip, some useful peripherals, and breakout pins onto one PCB, we call this a \u201cmicrocontroller\u201d. Everything you need to control and take basic digital/analog measurements on one board</p>"},{"location":"advanced/Using%20ChatGPT%20and%20TTS%2019f67bb8fd948155b328fe6aa8f42f6a/","title":"Using ChatGPT and TTS","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;WiFi.h&gt;\n#include &lt;HTTPClient.h&gt;\n#include &lt;ArduinoJson.h&gt;\n#include &lt;driver/i2s.h&gt;\n#include \"AudioOutputI2S.h\"\n#include \"AudioGeneratorMP3.h\"\n#include \"AudioFileSourceBuffer.h\"\n#include \"AudioFileSourceHTTPStream.h\"\n\n// Pin definitions\n#define I2S_BCLK_PIN       8  // Bit clock\n#define I2S_LRCLK_PIN      9  // Left/Right clock (Word Select)\n#define I2S_DATA_PIN       10 // Data pin\n\n// Network credentials\nconst char* ssid = \"YOURSSIDHERE\";\nconst char* password = \"YOURPASSWORDHERE\";\n\n// OpenAI API configuration\nconst char* openai_api_key = \"YOURAPIKEYHERE\";\nconst char* openai_endpoint = \"https://api.openai.com/v1/chat/completions\";\n\n// VoiceRSS TTS configuration\nconst char* tts_endpoint = \"http://api.voicerss.org/\";\nconst char* tts_api_key = \"YOURAPIKEYHERE\";\n\n// Audio objects\nAudioOutputI2S *out;\nAudioGeneratorMP3 *mp3;\nAudioFileSourceHTTPStream *file;\nAudioFileSourceBuffer *buff;\n\n// Buffer for audio streaming\nuint8_t* audio_buffer;\nconst int BUFFER_SIZE = 8192;\n\n// Initialize I2S configuration\nvoid initI2S() {\n    i2s_config_t i2s_config = {\n        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\n        .sample_rate = 16000,  // Match the TTS audio sample rate\n        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\n        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,  // Stereo\n        .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n        .dma_buf_count = 8,\n        .dma_buf_len = 64,\n        .use_apll = false,\n        .tx_desc_auto_clear = true,\n        .fixed_mclk = 0\n    };\n\n    // ... rest of the function remains unchanged\n}\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Connect to WiFi\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.println(\"\\nConnected to WiFi\");\n\n    // Initialize I2S\n    initI2S();\n    out = new AudioOutputI2S();\n    out-&gt;SetPinout(I2S_BCLK_PIN, I2S_LRCLK_PIN, I2S_DATA_PIN);\n    out-&gt;SetGain(0.5);\n\n    // Initialize audio buffer\n    audio_buffer = (uint8_t*)malloc(BUFFER_SIZE);\n    mp3 = new AudioGeneratorMP3();\n}\n\nString urlencode(String str) {\n    String encodedString = \"\";\n    char c;\n    char code0;\n    char code1;\n    for (int i = 0; i &lt; str.length(); i++){\n        c = str.charAt(i);\n        if (isalnum(c)){\n            encodedString += c;\n        } else {\n            encodedString += '%';\n            code0 = (c &gt;&gt; 4) &amp; 0xF;\n            code1 = c &amp; 0xF;\n            code0 += code0 &gt; 9 ? 'A' - 10 : '0';\n            code1 += code1 &gt; 9 ? 'A' - 10 : '0';\n            encodedString += code0;\n            encodedString += code1;\n        }\n    }\n    return encodedString;\n}\n\nString getChatGPTResponse(String userInput) {\n    if (WiFi.status() != WL_CONNECTED) {\n        return \"WiFi not connected\";\n    }\n\n    HTTPClient http;\n    http.begin(openai_endpoint);\n    http.addHeader(\"Content-Type\", \"application/json\");\n    http.addHeader(\"Authorization\", String(\"Bearer \") + openai_api_key);\n\n    // Prepare the request payload\n    StaticJsonDocument&lt;2048&gt; doc;  // Increase size if necessary\n    doc[\"model\"] = \"gpt-3.5-turbo\";  // Update model as needed\n    JsonArray messages = doc.createNestedArray(\"messages\");\n\n    // You can add previous conversation turns to maintain context\n    JsonObject userMessage = messages.createNestedObject();\n    userMessage[\"role\"] = \"user\";\n    userMessage[\"content\"] = userInput;\n\n    String requestBody;\n    serializeJson(doc, requestBody);\n\n    int httpResponseCode = http.POST(requestBody);\n    String response = \"\";\n\n    if (httpResponseCode == HTTP_CODE_OK) {\n        response = http.getString();\n        // Parse the response\n        StaticJsonDocument&lt;6144&gt; responseDoc;  // Adjust size as needed\n        DeserializationError error = deserializeJson(responseDoc, response);\n        if (!error) {\n            response = responseDoc[\"choices\"][0][\"message\"][\"content\"].as&lt;String&gt;();\n        } else {\n            Serial.println(\"Error parsing response\");\n            response = \"Error parsing response\";\n        }\n    } else {\n        Serial.printf(\"OpenAI API request failed with code %d\\n\", httpResponseCode);\n        response = \"Error in API request\";\n    }\n\n    http.end();\n    return response;\n}\n\nbool textToSpeech(String text) {\n    if (WiFi.status() != WL_CONNECTED) {\n        return false;\n    }\n\n    // URL encode the text\n    String encodedText = urlencode(text);\n\n    // Construct the URL for the TTS request\n    String url = String(tts_endpoint) +\n                 \"?key=\" + tts_api_key +\n                 \"&amp;hl=en-us\" +   // Language\n                 \"&amp;c=MP3\" +      // Codec\n                 \"&amp;f=16khz_16bit_stereo\" +  // Format\n                 \"&amp;src=\" + encodedText;\n\n    Serial.println(\"TTS Request URL: \" + url);\n\n    // Clean up previous audio sources\n    if (file != nullptr) {\n        delete file;\n        file = nullptr;\n    }\n    if (buff != nullptr) {\n        delete buff;\n        buff = nullptr;\n    }\n\n    // Create audio source from the TTS URL\n    file = new AudioFileSourceHTTPStream(url.c_str());\n    buff = new AudioFileSourceBuffer(file, audio_buffer, BUFFER_SIZE);\n    mp3-&gt;begin(buff, out);\n    return true;\n}\n\nvoid loop() {\n    if (Serial.available()) {\n        String userInput = Serial.readStringUntil('\\n');\n        Serial.println(\"You: \" + userInput);\n\n        // Get ChatGPT response\n        String response = getChatGPTResponse(userInput);\n        Serial.println(\"ChatGPT: \" + response);\n\n        // Convert response to speech and play\n        if (textToSpeech(response)) {\n            Serial.println(\"Playing audio response...\");\n        } else {\n            Serial.println(\"Failed to get audio response\");\n        }\n    }\n\n    // Handle audio playback\n    if (mp3-&gt;isRunning()) {\n        if (!mp3-&gt;loop()) {\n            mp3-&gt;stop();\n\n            if (buff != nullptr) {\n                delete buff;\n                buff = nullptr;\n            }\n\n            if (file != nullptr) {\n                file-&gt;close();\n                delete file;\n                file = nullptr;\n            }\n        }\n    }\n\n    // Add a small delay to prevent watchdog timer issues\n    delay(1);\n}\n</code></pre>"},{"location":"basics/","title":"Learning the Basics","text":""},{"location":"basics/#this-zone-is-under-construction","title":"THIS ZONE IS UNDER CONSTRUCTION","text":""},{"location":"basics/gpio/","title":"Using GPIO","text":"<p>This page was created by live-edit.</p>"},{"location":"basics/i2c/","title":"Using I2C","text":"<p>This page was created by live-edit.</p>"},{"location":"basics/imu/","title":"Using the IMU","text":"<p>This page was created by live-edit.</p>"},{"location":"basics/sdcard/","title":"Using the SD Card","text":"<p>This page was created by live-edit.</p>"},{"location":"basics/serial/","title":"Using the Serial Monitor &amp; Plotter","text":"<p>This page was created by live-edit.</p>"},{"location":"basics/tinyproto/","title":"Using the tinyProto","text":"<p>This page was created by live-edit.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/11/19/adc-mcp/","title":"ADC + MCP7428 Test","text":"Note: This test was run before the custom Arduino library was written. This means we needed to use specific workarounds to remap pins for our ADC Test.   <pre><code>#include &lt;Adafruit_MCP4728.h&gt;\n#include &lt;Wire.h&gt;\n#include \"driver/adc.h\"\n#include \"esp_adc/adc_oneshot.h\"\n\nAdafruit_MCP4728 mcp;\n\n// Constants\nconst int ANALOG_PIN = 18;  // GPIO18, ADC2_CH7\nconst unsigned long LIGHT_CHANGE_INTERVAL = 10000;  // 10ms in microseconds\nconst int LED_VALUE = 310;  // LED brightness value\nconst unsigned long SAMPLE_INTERVAL = 25;  // 25 microseconds\n\n// Variables for timing\nunsigned long lastSampleMicros = 0;\nunsigned long lastLightMicros = 0;\nuint8_t currentLight = 0;\nvolatile uint16_t analogBuffer[100];  // Buffer for analog readings\nvolatile uint8_t bufferIndex = 0;\nvolatile bool bufferFull = false;\n\n// ADC handles\nadc_oneshot_unit_handle_t adc2_handle;\nadc_oneshot_unit_init_cfg_t init_config2;\nadc_oneshot_chan_cfg_t config;\n\nvoid setup(void) {\n  Serial.begin(2000000);  // Increased baud rate for faster data transmission\n\n  // Initialize I2C and LED control\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  Wire.begin(3, 4);\n  Wire.setClock(800000);  // Set I2C clock to 800kHz for faster communication\n  delay(100);  // Give I2C time to stabilize\n\n  // Try to initialize MCP4728\n  if (!mcp.begin()) {\n    Serial.println(\"Failed to find MCP4728 chip\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  // Configure ADC\n  init_config2.unit_id = ADC_UNIT_2;  // Using ADC2\n  init_config2.ulp_mode = ADC_ULP_MODE_DISABLE;\n  init_config2.clk_src = ADC_RTC_CLK_SRC_DEFAULT;\n  ESP_ERROR_CHECK(adc_oneshot_new_unit(&amp;init_config2, &amp;adc2_handle));\n\n  // Configure ADC channel\n  config.atten = ADC_ATTEN_DB_11;\n  config.bitwidth = ADC_BITWIDTH_12;\n  ESP_ERROR_CHECK(adc_oneshot_config_channel(adc2_handle, ADC_CHANNEL_7, &amp;config));  // ADC2_CH7 for GPIO18\n\n  // Initialize all channels to 0\n  mcp.setChannelValue(MCP4728_CHANNEL_A, 0);\n  mcp.setChannelValue(MCP4728_CHANNEL_B, 0);\n  mcp.setChannelValue(MCP4728_CHANNEL_C, 0);\n  mcp.setChannelValue(MCP4728_CHANNEL_D, 0);\n\n  // Print header for Serial Plotter\n  Serial.println(\"Light_Level Channel_A Channel_B Channel_C Channel_D\");\n}\n\nvoid loop() {\n  unsigned long currentMicros = micros();\n\n  // Sample analog input every 50 microseconds\n  if (currentMicros - lastSampleMicros &gt;= SAMPLE_INTERVAL) {\n    lastSampleMicros = currentMicros;\n\n    // Read ADC\n    int adc_value;\n    if (adc_oneshot_read(adc2_handle, ADC_CHANNEL_7, &amp;adc_value) == ESP_OK) {\n      analogBuffer[bufferIndex] = adc_value;\n\n      // Print the values and LED states\n      Serial.println(analogBuffer[bufferIndex]);\n      // Serial.print(\" \");\n      // Serial.print(currentLight == 0 ? LED_VALUE : 0);\n      // Serial.print(\" \");\n      // Serial.print(currentLight == 1 ? LED_VALUE : 0);\n      // Serial.print(\" \");\n      // Serial.print(currentLight == 2 ? LED_VALUE : 0);\n      // Serial.print(\" \");\n      // Serial.println(currentLight == 3 ? LED_VALUE : 0);\n\n      bufferIndex = (bufferIndex + 1) % 100;\n      if (bufferIndex == 0) {\n        bufferFull = true;\n      }\n    }\n  }\n\n  // Change lights every 10ms (10,000 microseconds)\n  if (currentMicros - lastLightMicros &gt;= LIGHT_CHANGE_INTERVAL) {\n    lastLightMicros = currentMicros;\n\n    // Turn off all LEDs\n    mcp.setChannelValue(MCP4728_CHANNEL_A, 0);\n    mcp.setChannelValue(MCP4728_CHANNEL_B, 0);\n    mcp.setChannelValue(MCP4728_CHANNEL_C, 0);\n    mcp.setChannelValue(MCP4728_CHANNEL_D, 0);\n\n    // If we're not in the \"all off\" state, turn on the current LED\n    if (currentLight &lt; 4) {\n      switch(currentLight) {\n        case 0:\n          mcp.setChannelValue(MCP4728_CHANNEL_A, LED_VALUE);\n          break;\n        case 1:\n          mcp.setChannelValue(MCP4728_CHANNEL_B, LED_VALUE);\n          break;\n        case 2:\n          mcp.setChannelValue(MCP4728_CHANNEL_C, LED_VALUE);\n          break;\n        case 3:\n          mcp.setChannelValue(MCP4728_CHANNEL_D, LED_VALUE);\n          break;\n      }\n    }\n\n    // Increment light counter\n    currentLight = (currentLight + 1) % 5;  // 5 states: 4 LEDs + all off\n  }\n}\n</code></pre> <p>This code was actually written for the tinyHEG prototype, which uses the MCP4728 DAC to control 4 LEDs. The Analog 0 pin is connected to one photodetector, which was looking at channel C. </p> <p>This worked great, and we got good data from the Analog pin. So I threw the program back in to Claude and simplified it to only use one channel:</p> <pre><code>#include &lt;Adafruit_MCP4728.h&gt;\n#include &lt;Wire.h&gt;\n#include \"driver/adc.h\"\n#include \"esp_adc/adc_oneshot.h\"\n\nAdafruit_MCP4728 mcp;\n\n// Constants\nconst int ANALOG_PIN = 18;  // GPIO18, ADC2_CH7\nconst int LED_VALUE = 400;  // LED brightness value\nconst unsigned long TOGGLE_INTERVAL = 25;  // 100 microseconds toggle interval\nconst unsigned long SAMPLE_DELAY = 10;  // Wait 50 microseconds after toggling before sampling\nconst int BATCH_SIZE = 100;  // Number of samples to collect before printing\n\n// Variables for timing and measurements\nunsigned long lastToggleMicros = 0;\nunsigned long lastSampleTime = 0;\nbool channelCState = false;\nint highSample = 0;\nint lowSample = 0;\n\n// Batch processing variables\nint differenceSum = 0;\nunsigned long intervalSum = 0;\nint sampleCount = 0;\n\n// ADC handles\nadc_oneshot_unit_handle_t adc2_handle;\nadc_oneshot_unit_init_cfg_t init_config2;\nadc_oneshot_chan_cfg_t config;\n\nvoid setup(void) {\n  Serial.begin(2000000);\n\n  // Initialize I2C and LED control\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  Wire.begin(3, 4);\n  Wire.setClock(800000);\n  delay(100);\n\n  if (!mcp.begin()) {\n    Serial.println(\"Failed to find MCP4728 chip\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  // Configure ADC\n  init_config2.unit_id = ADC_UNIT_2;\n  init_config2.ulp_mode = ADC_ULP_MODE_DISABLE;\n  init_config2.clk_src = ADC_RTC_CLK_SRC_DEFAULT;\n  ESP_ERROR_CHECK(adc_oneshot_new_unit(&amp;init_config2, &amp;adc2_handle));\n\n  // Configure ADC channel\n  config.atten = ADC_ATTEN_DB_11;\n  config.bitwidth = ADC_BITWIDTH_12;\n  ESP_ERROR_CHECK(adc_oneshot_config_channel(adc2_handle, ADC_CHANNEL_7, &amp;config));\n\n  // Initialize all channels to 0\n  mcp.setChannelValue(MCP4728_CHANNEL_A, 0);\n  mcp.setChannelValue(MCP4728_CHANNEL_B, 0);\n  mcp.setChannelValue(MCP4728_CHANNEL_C, 0);\n  mcp.setChannelValue(MCP4728_CHANNEL_D, 0);\n\n  // Initialize timing variables\n  lastSampleTime = micros();\n\n  // Print header\n  Serial.println(\"Average_Difference,Average_Sample_Interval_us\");\n}\n\nvoid loop() {\n  unsigned long currentMicros = micros();\n\n  if (currentMicros - lastToggleMicros &gt;= TOGGLE_INTERVAL) {\n    lastToggleMicros = currentMicros;\n\n    // Calculate time since last sample\n    unsigned long sampleInterval = currentMicros - lastSampleTime;\n    lastSampleTime = currentMicros;\n\n    // Turn on Channel C\n    mcp.setChannelValue(MCP4728_CHANNEL_C, LED_VALUE);\n    delayMicroseconds(SAMPLE_DELAY);  // Wait for signal to stabilize\n\n    // Take high sample\n    if (adc_oneshot_read(adc2_handle, ADC_CHANNEL_7, &amp;highSample) != ESP_OK) {\n      highSample = 0;  // In case of error\n    }\n\n    // Turn off Channel C\n    mcp.setChannelValue(MCP4728_CHANNEL_C, 0);\n    delayMicroseconds(SAMPLE_DELAY);  // Wait for signal to stabilize\n\n    // Take low sample\n    if (adc_oneshot_read(adc2_handle, ADC_CHANNEL_7, &amp;lowSample) != ESP_OK) {\n      lowSample = 0;  // In case of error\n    }\n\n    // Calculate difference and add to sum\n    int difference = highSample - lowSample;\n    differenceSum += difference;\n    intervalSum += sampleInterval;\n    sampleCount++;\n\n    // If we've collected BATCH_SIZE samples, calculate and print averages\n    if (sampleCount &gt;= BATCH_SIZE) {\n      float avgDifference = (float)differenceSum / BATCH_SIZE;\n      float avgInterval = (float)intervalSum / BATCH_SIZE;\n\n      // Print averages\n      Serial.print(avgDifference);\n      Serial.print(\",\");\n      Serial.println(avgInterval);\n\n      // Reset counters and sums\n      differenceSum = 0;\n      intervalSum = 0;\n      sampleCount = 0;\n    }\n  }\n}\n</code></pre> <p>This worked as well, so then I switched to an MCP4725, which is a single channel DAC to control the LED:</p> <pre><code>#include &lt;Adafruit_MCP4725.h&gt;\n#include &lt;Wire.h&gt;\n#include \"driver/adc.h\"\n#include \"esp_adc/adc_oneshot.h\"\n\nAdafruit_MCP4725 dac;\n\n// Constants\nconst int ANALOG_PIN = 18;  // GPIO18, ADC2_CH7\nconst int LED_VALUE = 400;  // LED brightness value\nconst unsigned long TOGGLE_INTERVAL = 25;  // 100 microseconds toggle interval\nconst unsigned long SAMPLE_DELAY = 10;  // Wait 50 microseconds after toggling before sampling\nconst int BATCH_SIZE = 100;  // Number of samples to collect before printing\n\n// Variables for timing and measurements\nunsigned long lastToggleMicros = 0;\nunsigned long lastSampleTime = 0;\nbool ledState = false;\nint highSample = 0;\nint lowSample = 0;\n\n// Batch processing variables\nint differenceSum = 0;\nunsigned long intervalSum = 0;\nint sampleCount = 0;\n\n// ADC handles\nadc_oneshot_unit_handle_t adc2_handle;\nadc_oneshot_unit_init_cfg_t init_config2;\nadc_oneshot_chan_cfg_t config;\n\nvoid setup(void) {\n  Serial.begin(2000000);\n\n  // Initialize I2C and LED control\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  Wire.begin(3, 4);\n  Wire.setClock(800000);\n  delay(100);\n\n  if (!dac.begin(0x62)) {  // Default I2C address for MCP4725\n    Serial.println(\"Failed to find MCP4725 chip\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  // Configure ADC\n  init_config2.unit_id = ADC_UNIT_2;\n  init_config2.ulp_mode = ADC_ULP_MODE_DISABLE;\n  init_config2.clk_src = ADC_RTC_CLK_SRC_DEFAULT;\n  ESP_ERROR_CHECK(adc_oneshot_new_unit(&amp;init_config2, &amp;adc2_handle));\n\n  // Configure ADC channel\n  config.atten = ADC_ATTEN_DB_11;\n  config.bitwidth = ADC_BITWIDTH_12;\n  ESP_ERROR_CHECK(adc_oneshot_config_channel(adc2_handle, ADC_CHANNEL_7, &amp;config));\n\n  // Initialize DAC to 0\n  dac.setVoltage(0, false);\n\n  // Initialize timing variables\n  lastSampleTime = micros();\n\n  // Print header\n  Serial.println(\"Average_Difference,Average_Sample_Interval_us\");\n}\n\nvoid loop() {\n  unsigned long currentMicros = micros();\n\n  if (currentMicros - lastToggleMicros &gt;= TOGGLE_INTERVAL) {\n    lastToggleMicros = currentMicros;\n\n    // Calculate time since last sample\n    unsigned long sampleInterval = currentMicros - lastSampleTime;\n    lastSampleTime = currentMicros;\n\n    // Set DAC output high\n    dac.setVoltage(LED_VALUE, false);\n    delayMicroseconds(SAMPLE_DELAY);  // Wait for signal to stabilize\n\n    // Take high sample\n    if (adc_oneshot_read(adc2_handle, ADC_CHANNEL_7, &amp;highSample) != ESP_OK) {\n      highSample = 0;  // In case of error\n    }\n\n    // Set DAC output low\n    dac.setVoltage(0, false);\n    delayMicroseconds(SAMPLE_DELAY);  // Wait for signal to stabilize\n\n    // Take low sample\n    if (adc_oneshot_read(adc2_handle, ADC_CHANNEL_7, &amp;lowSample) != ESP_OK) {\n      lowSample = 0;  // In case of error\n    }\n\n    // Calculate difference and add to sum\n    int difference = highSample - lowSample;\n    differenceSum += difference;\n    intervalSum += sampleInterval;\n    sampleCount++;\n\n    // If we've collected BATCH_SIZE samples, calculate and print averages\n    if (sampleCount &gt;= BATCH_SIZE) {\n      float avgDifference = (float)differenceSum / BATCH_SIZE;\n      float avgInterval = (float)intervalSum / BATCH_SIZE;\n\n      // Print averages\n      Serial.print(avgDifference);\n      Serial.print(\",\");\n      Serial.println(avgInterval);\n\n      // Reset counters and sums\n      differenceSum = 0;\n      intervalSum = 0;\n      sampleCount = 0;\n    }\n  }\n}\n</code></pre>","tags":["example","code","ADC","MCP7428"]},{"location":"blog/2024/10/28/boot-up-test/","title":"Boot Up and Flash Test","text":"<p>Had some issues with Serial Monitor not working, and the device not being recognized, it was confusing to get down, but I solved those issues.</p> <ol> <li> <p>ERR light turns on during operation</p> <p>Apparently this is normal, ERR LED is connected to GPIO21, which is the Debug pin on the ESP32-S3. This means that it pulls low when it's in debug, and defaults high in regular mode (although this can be overridden in code [TESTED]).</p> </li> </ol> <pre><code>On our next revision, we should pull this pin active low, so that it turns on to signify bootloader mode. Speaking of bootloader mode...\n</code></pre> <ol> <li> <p>Board not recognized (not in Boot Mode)</p> <p>To get into Boot Mode, you have to hold down the BOOT button, press the RESET button momentarily (While still holding down BOOT), and then release the BOOT button.</p> <p>On Rev. 1 the ERR light will turn off if you did this successfully. </p> <p>This may change the COM Port! Be sure to check in the IDE before flashing.</p> </li> <li> <p>Serial Monitor not working</p> <p>There are a bunch of weird flash settings on Arduino that do not initialize correctly when you choose the board, and sometimes they reset when you open up the IDE after closing. </p> <p>To fix this, make sure that these are your settings:</p> <p></p> <p>The big ones are </p> <ul> <li>Upload Mode: \"UART0 / Hardware CDC\"</li> <li>USB Mode: \"Hardware CDC and JTAG\"</li> <li>USB CDC On Boot: \"Enabled\"</li> </ul> <p>This should fix the errors with serial monitor.</p> </li> </ol> <p>Board works and boots using Adafruit ESP32-S3 No PSRAM Board.</p> <p>Needs to have it's own Arduino Board file developed.</p>","tags":["example","programming","flashing","boot"]},{"location":"blog/2024/11/23/custom-arduino-library/","title":"Custom Arduino Library","text":"<p>Our board needed a custom Arduino library, so I went through and made our own. First I started by copying the adafruit_feather_esp32s3_nopsram folder from:</p> <p>C:\\Users\\macge\\AppData\\Local\\Arduino15\\packages\\esp32\\hardware\\esp32\\3.1.0-RC2\\variants</p> <p>I renamed this file to \"iota_core_esp32s3_nopsram\". (This is very important to remember, because this name definition must match exactly with the boards.txt file we will edit later.)</p> <p>Within the folder there are four files:    </p> <p></p> <p>We will want to edit both variant.cpp and pins_arduino.h.</p> <p>Let's start with pins_arduino.h:</p> <pre><code>#ifndef Pins_Arduino_h\n#define Pins_Arduino_h\n\n#include &lt;stdint.h&gt;\n#include \"soc/soc_caps.h\"\n\n#define USB_VID          0x239A\n#define USB_PID          0x8113\n#define USB_MANUFACTURER \"Mister Industries\"\n#define USB_PRODUCT      \"iotaCore ESP32-S3 No PSRAM\"\n#define USB_SERIAL       \"\"  // Empty string for MAC address\n\n// User LED\n#define LED_BUILTIN 33\n#define BUILTIN_LED LED_BUILTIN  // Maps to the SIG LED Pin\n\n#define I2C_POWER         6     // I2C power pin\n#define PIN_I2C_POWER     6     // I2C power pin\n\nstatic const uint8_t TX = 39;\nstatic const uint8_t RX = 38;\n#define TX1 TX\n#define RX1 RX\n\nstatic const uint8_t SDA = 3;\nstatic const uint8_t SCL = 4;\n\nstatic const uint8_t SS = 1;\nstatic const uint8_t MOSI = 35;\nstatic const uint8_t SCK = 36;\nstatic const uint8_t MISO = 37;\n\nstatic const uint8_t A0 = 18;\nstatic const uint8_t A1 = 17;\nstatic const uint8_t A2 = 16;\nstatic const uint8_t A3 = 15;\nstatic const uint8_t A4 = 14;\nstatic const uint8_t A5 = 7;\nstatic const uint8_t A6 = 3;\nstatic const uint8_t A7 = 4;\nstatic const uint8_t A8 = 5;\nstatic const uint8_t A9 = 9;\nstatic const uint8_t A10 = 10;\nstatic const uint8_t A11 = 11;\nstatic const uint8_t A12 = 12;\nstatic const uint8_t A13 = 13;\n\nstatic const uint8_t T3 = 3;\nstatic const uint8_t T4 = 4;\nstatic const uint8_t T5 = 5;\nstatic const uint8_t T8 = 8;\nstatic const uint8_t T9 = 9;\nstatic const uint8_t T10 = 10;\nstatic const uint8_t T11 = 11;\nstatic const uint8_t T12 = 12;\nstatic const uint8_t T13 = 13;\nstatic const uint8_t T14 = 14;\n\n#endif /* Pins_Arduino_h */\n</code></pre> <p>The changes I made from the Adafruit library were:</p> <ul> <li>Changing the manufacturer and product names</li> <li>Updating the built-in LED to Pin 33</li> <li>Removing the NEOPixel definitions</li> <li>Updated I2C Power pins to Pin 6 (instead of 7)</li> <li>Changed the SD Card CS pin to 1</li> <li>Updated A5 to Pin 7 (instead of 8)</li> <li>Updated A9 to Pin 9 (instead of 9)</li> <li>Removed T6 (since it's being used for I2C_PWR)</li> </ul>","tags":["example","code","library","Arduino"]},{"location":"blog/2024/11/23/custom-arduino-library/#then-we-need-to-update-variantscpp","title":"Then we need to update variants.cpp","text":"<p>All I did for this was remove the NEOPixel definitions</p> <pre><code>// This board has a power control pin, and we must set it to output and high\n// in order to enable the NeoPixels.\npinMode(NEOPIXEL_POWER, OUTPUT);\ndigitalWrite(NEOPIXEL_POWER, HIGH);\n</code></pre>","tags":["example","code","library","Arduino"]},{"location":"blog/2024/11/23/custom-arduino-library/#next-we-will-update-boardstxt","title":"Next we will update boards.txt!","text":"<p>For this, we will copy the board entry for Adafruit's ESP32-S3 No PSRAM, and then modify with our device name we chose earlier:</p> <pre><code>##############################################################\n# iotaCore ESP32-S3 No PSRAM\n\niota_core_esp32s3_nopsram.name=iotaCore ESP32-S3 No PSRAM\niota_core_esp32s3_nopsram.vid.0=0x239A\niota_core_esp32s3_nopsram.pid.0=0x8113\niota_core_esp32s3_nopsram.vid.1=0x239A\niota_core_esp32s3_nopsram.pid.1=0x0113\niota_core_esp32s3_nopsram.vid.2=0x239A\niota_core_esp32s3_nopsram.pid.2=0x8114\niota_core_esp32s3_nopsram.upload_port.0.vid=0x239A\niota_core_esp32s3_nopsram.upload_port.0.pid=0x8113\niota_core_esp32s3_nopsram.upload_port.1.vid=0x239A\niota_core_esp32s3_nopsram.upload_port.1.pid=0x0113\niota_core_esp32s3_nopsram.upload_port.2.vid=0x239A\niota_core_esp32s3_nopsram.upload_port.2.pid=0x8114\n\niota_core_esp32s3_nopsram.bootloader.tool=esptool_py\niota_core_esp32s3_nopsram.bootloader.tool.default=esptool_py\n\niota_core_esp32s3_nopsram.upload.tool=esptool_py\niota_core_esp32s3_nopsram.upload.tool.default=esptool_py\niota_core_esp32s3_nopsram.upload.tool.network=esp_ota\n\niota_core_esp32s3_nopsram.upload.maximum_size=1310720\niota_core_esp32s3_nopsram.upload.maximum_data_size=327680\niota_core_esp32s3_nopsram.upload.flags=\niota_core_esp32s3_nopsram.upload.extra_flags=\niota_core_esp32s3_nopsram.upload.use_1200bps_touch=true\niota_core_esp32s3_nopsram.upload.wait_for_upload_port=true\n\niota_core_esp32s3_nopsram.serial.disableDTR=false\niota_core_esp32s3_nopsram.serial.disableRTS=false\n\niota_core_esp32s3_nopsram.build.tarch=xtensa\niota_core_esp32s3_nopsram.build.bootloader_addr=0x0\niota_core_esp32s3_nopsram.build.target=esp32s3\niota_core_esp32s3_nopsram.build.mcu=esp32s3\niota_core_esp32s3_nopsram.build.core=esp32\niota_core_esp32s3_nopsram.build.variant=iota_core_esp32s3_nopsram\niota_core_esp32s3_nopsram.build.board=IOTA_CORE_ESP32S3_NOPSRAM\n\niota_core_esp32s3_nopsram.build.usb_mode=0\niota_core_esp32s3_nopsram.build.cdc_on_boot=1\niota_core_esp32s3_nopsram.build.msc_on_boot=0\niota_core_esp32s3_nopsram.build.dfu_on_boot=0\niota_core_esp32s3_nopsram.build.f_cpu=240000000L\niota_core_esp32s3_nopsram.build.flash_size=8MB\niota_core_esp32s3_nopsram.build.flash_freq=80m\niota_core_esp32s3_nopsram.build.flash_mode=dio\niota_core_esp32s3_nopsram.build.boot=qio\niota_core_esp32s3_nopsram.build.partitions=default\niota_core_esp32s3_nopsram.build.defines=\niota_core_esp32s3_nopsram.build.loop_core=\niota_core_esp32s3_nopsram.build.event_core=\niota_core_esp32s3_nopsram.build.flash_type=qio\niota_core_esp32s3_nopsram.build.psram_type=qspi\niota_core_esp32s3_nopsram.build.memory_type={build.flash_type}_{build.psram_type}\n\niota_core_esp32s3_nopsram.menu.LoopCore.1=Core 1\niota_core_esp32s3_nopsram.menu.LoopCore.1.build.loop_core=-DARDUINO_RUNNING_CORE=1\niota_core_esp32s3_nopsram.menu.LoopCore.0=Core 0\niota_core_esp32s3_nopsram.menu.LoopCore.0.build.loop_core=-DARDUINO_RUNNING_CORE=0\n\niota_core_esp32s3_nopsram.menu.EventsCore.1=Core 1\niota_core_esp32s3_nopsram.menu.EventsCore.1.build.event_core=-DARDUINO_EVENT_RUNNING_CORE=1\niota_core_esp32s3_nopsram.menu.EventsCore.0=Core 0\niota_core_esp32s3_nopsram.menu.EventsCore.0.build.event_core=-DARDUINO_EVENT_RUNNING_CORE=0\n\niota_core_esp32s3_nopsram.menu.USBMode.default=Hardware CDC and JTAG\niota_core_esp32s3_nopsram.menu.USBMode.default.build.usb_mode=1\niota_core_esp32s3_nopsram.menu.USBMode.hwcdc=USB-OTG (TinyUSB)\niota_core_esp32s3_nopsram.menu.USBMode.hwcdc.build.usb_mode=0\n\niota_core_esp32s3_nopsram.menu.CDCOnBoot.cdc=Enabled\niota_core_esp32s3_nopsram.menu.CDCOnBoot.cdc.build.cdc_on_boot=1\niota_core_esp32s3_nopsram.menu.CDCOnBoot.default=Disabled\niota_core_esp32s3_nopsram.menu.CDCOnBoot.default.build.cdc_on_boot=0\n\niota_core_esp32s3_nopsram.menu.MSCOnBoot.default=Disabled\niota_core_esp32s3_nopsram.menu.MSCOnBoot.default.build.msc_on_boot=0\niota_core_esp32s3_nopsram.menu.MSCOnBoot.msc=Enabled (Requires USB-OTG Mode)\niota_core_esp32s3_nopsram.menu.MSCOnBoot.msc.build.msc_on_boot=1\n\niota_core_esp32s3_nopsram.menu.DFUOnBoot.default=Disabled\niota_core_esp32s3_nopsram.menu.DFUOnBoot.default.build.dfu_on_boot=0\niota_core_esp32s3_nopsram.menu.DFUOnBoot.dfu=Enabled (Requires USB-OTG Mode)\niota_core_esp32s3_nopsram.menu.DFUOnBoot.dfu.build.dfu_on_boot=1\n\niota_core_esp32s3_nopsram.menu.UploadMode.default=UART0 / Hardware CDC\niota_core_esp32s3_nopsram.menu.UploadMode.default.upload.use_1200bps_touch=false\niota_core_esp32s3_nopsram.menu.UploadMode.default.upload.wait_for_upload_port=false\niota_core_esp32s3_nopsram.menu.UploadMode.cdc=USB-OTG CDC (TinyUSB)\niota_core_esp32s3_nopsram.menu.UploadMode.cdc.upload.use_1200bps_touch=true\niota_core_esp32s3_nopsram.menu.UploadMode.cdc.upload.wait_for_upload_port=true\n\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2=TinyUF2 8MB (2MB APP/3.7MB FATFS)\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2.build.custom_bootloader=bootloader-tinyuf2\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2.build.partitions=tinyuf2-partitions-8MB\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2.upload.maximum_size=2097152\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2.upload.extra_flags=0x410000 \"{runtime.platform.path}/variants/{build.variant}/tinyuf2.bin\"\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2_noota=TinyUF2 8MB No OTA (4MB APP/3.7MB FATFS)\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2_noota.build.custom_bootloader=bootloader-tinyuf2\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2_noota.build.partitions=tinyuf2-partitions-8MB-noota\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2_noota.upload.maximum_size=4194304\niota_core_esp32s3_nopsram.menu.PartitionScheme.tinyuf2_noota.upload.extra_flags=0x410000 \"{runtime.platform.path}/variants/{build.variant}/tinyuf2.bin\"\niota_core_esp32s3_nopsram.menu.PartitionScheme.default_8MB=Default (3MB APP/1.5MB SPIFFS)\niota_core_esp32s3_nopsram.menu.PartitionScheme.default_8MB.build.partitions=default_8MB\niota_core_esp32s3_nopsram.menu.PartitionScheme.default_8MB.upload.maximum_size=3342336\n\niota_core_esp32s3_nopsram.menu.CPUFreq.240=240MHz (WiFi)\niota_core_esp32s3_nopsram.menu.CPUFreq.240.build.f_cpu=240000000L\niota_core_esp32s3_nopsram.menu.CPUFreq.160=160MHz (WiFi)\niota_core_esp32s3_nopsram.menu.CPUFreq.160.build.f_cpu=160000000L\niota_core_esp32s3_nopsram.menu.CPUFreq.80=80MHz (WiFi)\niota_core_esp32s3_nopsram.menu.CPUFreq.80.build.f_cpu=80000000L\niota_core_esp32s3_nopsram.menu.CPUFreq.40=40MHz\niota_core_esp32s3_nopsram.menu.CPUFreq.40.build.f_cpu=40000000L\niota_core_esp32s3_nopsram.menu.CPUFreq.20=20MHz\niota_core_esp32s3_nopsram.menu.CPUFreq.20.build.f_cpu=20000000L\niota_core_esp32s3_nopsram.menu.CPUFreq.10=10MHz\niota_core_esp32s3_nopsram.menu.CPUFreq.10.build.f_cpu=10000000L\n\niota_core_esp32s3_nopsram.menu.FlashMode.qio=QIO 80MHz\niota_core_esp32s3_nopsram.menu.FlashMode.qio.build.flash_mode=dio\niota_core_esp32s3_nopsram.menu.FlashMode.qio.build.boot=qio\niota_core_esp32s3_nopsram.menu.FlashMode.qio.build.boot_freq=80m\niota_core_esp32s3_nopsram.menu.FlashMode.qio.build.flash_freq=80m\niota_core_esp32s3_nopsram.menu.FlashMode.qio120=QIO 120MHz\niota_core_esp32s3_nopsram.menu.FlashMode.qio120.build.flash_mode=dio\niota_core_esp32s3_nopsram.menu.FlashMode.qio120.build.boot=qio\niota_core_esp32s3_nopsram.menu.FlashMode.qio120.build.boot_freq=120m\niota_core_esp32s3_nopsram.menu.FlashMode.qio120.build.flash_freq=80m\niota_core_esp32s3_nopsram.menu.FlashMode.dio=DIO 80MHz\niota_core_esp32s3_nopsram.menu.FlashMode.dio.build.flash_mode=dio\niota_core_esp32s3_nopsram.menu.FlashMode.dio.build.boot=dio\niota_core_esp32s3_nopsram.menu.FlashMode.dio.build.boot_freq=80m\niota_core_esp32s3_nopsram.menu.FlashMode.dio.build.flash_freq=80m\niota_core_esp32s3_nopsram.menu.FlashMode.opi=OPI 80MHz\niota_core_esp32s3_nopsram.menu.FlashMode.opi.build.flash_mode=dout\niota_core_esp32s3_nopsram.menu.FlashMode.opi.build.boot=opi\niota_core_esp32s3_nopsram.menu.FlashMode.opi.build.boot_freq=80m\niota_core_esp32s3_nopsram.menu.FlashMode.opi.build.flash_freq=80m\n\niota_core_esp32s3_nopsram.menu.FlashSize.8M=8MB (64Mb)\niota_core_esp32s3_nopsram.menu.FlashSize.8M.build.flash_size=8MB\n\niota_core_esp32s3_nopsram.menu.UploadSpeed.921600=921600\niota_core_esp32s3_nopsram.menu.UploadSpeed.921600.upload.speed=921600\niota_core_esp32s3_nopsram.menu.UploadSpeed.115200=115200\niota_core_esp32s3_nopsram.menu.UploadSpeed.115200.upload.speed=115200\niota_core_esp32s3_nopsram.menu.UploadSpeed.256000.windows=256000\niota_core_esp32s3_nopsram.menu.UploadSpeed.256000.upload.speed=256000\niota_core_esp32s3_nopsram.menu.UploadSpeed.230400.windows.upload.speed=256000\niota_core_esp32s3_nopsram.menu.UploadSpeed.230400=230400\niota_core_esp32s3_nopsram.menu.UploadSpeed.230400.upload.speed=230400\niota_core_esp32s3_nopsram.menu.UploadSpeed.460800.linux=460800\niota_core_esp32s3_nopsram.menu.UploadSpeed.460800.macosx=460800\niota_core_esp32s3_nopsram.menu.UploadSpeed.460800.upload.speed=460800\niota_core_esp32s3_nopsram.menu.UploadSpeed.512000.windows=512000\niota_core_esp32s3_nopsram.menu.UploadSpeed.512000.upload.speed=512000\n\niota_core_esp32s3_nopsram.menu.DebugLevel.none=None\niota_core_esp32s3_nopsram.menu.DebugLevel.none.build.code_debug=0\niota_core_esp32s3_nopsram.menu.DebugLevel.error=Error\niota_core_esp32s3_nopsram.menu.DebugLevel.error.build.code_debug=1\niota_core_esp32s3_nopsram.menu.DebugLevel.warn=Warn\niota_core_esp32s3_nopsram.menu.DebugLevel.warn.build.code_debug=2\niota_core_esp32s3_nopsram.menu.DebugLevel.info=Info\niota_core_esp32s3_nopsram.menu.DebugLevel.info.build.code_debug=3\niota_core_esp32s3_nopsram.menu.DebugLevel.debug=Debug\niota_core_esp32s3_nopsram.menu.DebugLevel.debug.build.code_debug=4\niota_core_esp32s3_nopsram.menu.DebugLevel.verbose=Verbose\niota_core_esp32s3_nopsram.menu.DebugLevel.verbose.build.code_debug=5\n\niota_core_esp32s3_nopsram.menu.EraseFlash.none=Disabled\niota_core_esp32s3_nopsram.menu.EraseFlash.none.upload.erase_cmd=\niota_core_esp32s3_nopsram.menu.EraseFlash.all=Enabled\niota_core_esp32s3_nopsram.menu.EraseFlash.all.upload.erase_cmd=-e\n\niota_core_esp32s3_nopsram.menu.ZigbeeMode.default=Disabled\niota_core_esp32s3_nopsram.menu.ZigbeeMode.default.build.zigbee_mode=\niota_core_esp32s3_nopsram.menu.ZigbeeMode.default.build.zigbee_libs=\niota_core_esp32s3_nopsram.menu.ZigbeeMode.zczr=Zigbee ZCZR (coordinator/router)\niota_core_esp32s3_nopsram.menu.ZigbeeMode.zczr.build.zigbee_mode=-DZIGBEE_MODE_ZCZR\niota_core_esp32s3_nopsram.menu.ZigbeeMode.zczr.build.zigbee_libs=-lesp_zb_api_zczr -lesp_zb_cli_command -lzboss_stack.zczr -lzboss_port\n</code></pre> <p>I also re-arranged the UART0 / Hardware CDC and Hardware CDC and JTAG entries to defaults, so that we get rid of that pesky serial monitor issue when dealing with the default upload settings on Arduino. I don't know why Adafruit didn't fix this a long time ago...</p> <p>Make sure to update the variant and board names:</p> <pre><code>iota_core_esp32s3_nopsram.build.variant=iota_core_esp32s3_nopsram\niota_core_esp32s3_nopsram.build.board=IOTA_CORE_ESP32S3_NOPSRAM\n</code></pre> <p>And that's it! Now when you re-load Arduino, iotaCore will show up in the boards list in the IDE. Selecting the board and flashing the Blink example results in a working SIG light blinking!</p>","tags":["example","code","library","Arduino"]},{"location":"blog/2025/01/24/devlog-1/","title":"Devlog #1: Rev 2 and Enclosure Testing","text":"This post was made in Discord on 1/24/25  <p>Hey guys! I'll be trying to post periodic/bi-weekly updates on development more frequently in these channels. Here's what happened in the last two weeks. We are rapidly developing the tinyCore as the first element of our project. Revision 2 has been created, with some minor circuit modifications and bug fixes. We've ordered 20 of this board, on 1/14, and we expect the boards to arrive prior to 2/22.</p> <p></p> <p>Revision 1.0</p> <p></p> <p>Revision 2.0</p> <p>PCB Revision Notes:</p> <p>As you can see from the two revisions, we have made several changes:</p> <ol> <li>Rerouted Power lines to avoid cross-unders and improve noise</li> <li>Completely overhauled the backside silkscreen with useful information and icons</li> <li>Labeled the front buttons </li> <li>Renamed ERR Led to BOOT, and made active high, so now it will turn on when the user has the board in bootloader mode. (This status is one of my biggest complaints with ESP32 boards)</li> <li>Made the mounting holes larger (from 1.5mm to M3 screws) and moved components for headroom</li> <li>Added Ground Vias next to digital signal lines to decrease noise</li> </ol> <p>Things we chose not to change (yet):</p> <ol> <li>PCB Cutout underneath antenna.<ol> <li>We found no significant issue with performance having the PCB as-is during our wireless speed-tests. We will continue to investigate but it currently seems unnecessary for our applications.</li> </ol> </li> <li>Move Buttons away from PCB Antenna<ol> <li>Same thing here, the performance is fine, so we left them. (This was a tradeoff between size, form-factor, and performance. We chose size/form-factor.</li> </ol> </li> <li>Changing Headers to Sew-able Pads<ol> <li>Although recommended by wearables users, we did not make this change because it would significantly change the design, and does not serve a great purpose for our intended form-factor (in an enclosure). We are working on a possible breakout board that would allow for better sew-ability of the device. </li> </ol> </li> <li>Add Magnetometer (9-DOF Sensor Fusion)<ol> <li>This would be really cool, but is outside our scope right now. Accelerometer is the most versatile motion measurement, and we believe it covers our current user-base. This may be added in the future, but at the moment it would only increase BOM complexity and costs, and would benefit only a few of our customers.</li> </ol> </li> <li>JTAG Pads Exposure on PCB Backside<ol> <li>We did not add this since the ESP32-S3 already has JTAG-over-USB capabilities built in. Although it would be nice for mass manufacturing/firmware writing with bed-of-nails, it is out of scope for this revision.</li> </ol> </li> <li>Better Buttons<ol> <li>We're still using the old mushy buttons for now. Might fix at some point but this has been backlogged.</li> </ol> </li> </ol> <p>Silkscreen Updates:</p> <p>Our first silkscreen SUCKED. Mostly because it doesn't have one. Here's a comparison side-by-side of the revisions:</p> <p>Front:</p> <p></p> <p>(Old)</p> <p>Back:</p> <p></p> <p>(New)</p> <p></p> <p>(Old)</p> <p></p> <p>(New)</p> <p>As you can see, we've added a ton of new icons, logos, labels, etc. And most importantly, we've added the bootloader instructions for the ESP32-S3. (No more googling because you forgot the button sequences.)</p> <p>Enclosure Prototypes</p> <p>Lastly for our updates this week, we have been hard at work designing 3D Printable enclosures for the iotaCore. So far we've got a few different colors and options. All of these were printed on the Bambu X1 Carbon with multi-colors:</p> <p></p> <p></p> <p>Here's a few different versions of transparent cases:</p> <p></p> <p>And it can stack! (More on this soon)</p> <p></p> <p></p> <p>Things we still need to revise with the enclosures:</p> <ol> <li>Improve tolerances</li> <li>Add Heat-insets</li> <li>Add SD Card accessibility</li> <li>Add Screw Terminal version</li> <li>Experiment with other colors and using clear filament for light-pipes.</li> <li>Finish adding Buttons (TPU?)</li> </ol> <p>That's about it for this week! We've been experimenting with some expansion module prototypes for the tinyVoice and tinyDisplay as well, so we should have some updates on that soon!</p>","tags":["schematic","PCB","ECAD","Enclosure","tinyProto","Devlog"]},{"location":"blog/2025/02/23/devlog-2/","title":"Devlog #2: Boards Arrive & First Fulfillment!","text":"<p>A lot has happened in the last month! As an overview we've:</p> <ul> <li>Ordered, received, and tested our Rev. 2 boards</li> <li>Changed our name from iotaCore to tinyCore!</li> <li>Started flyering/marketing around CU campus</li> <li>Partnered with a wearable technologies course at CU to get hands-on beta-testing &amp; feedback</li> <li>Published our website and setup online payments</li> <li>Fulfilled our first orders!!</li> </ul> <p>tinyCore Updates:</p> <p>Revision 2 arrived in the mail with a slight delay from the Lunar New Year on Feb 18<sup>th</sup>!</p> <p>We immediately unboxed them for initial inspection, and they look sharp. </p> <p></p> <p></p> <p>So far we've tested over half of the boards, and no issues have been found. Here's our basic testing procedure:</p> <p>Testing Procedure:</p> <ul> <li>Connect to PC via USB (Should be recognized as generic ESP32 device, and will be connecting &amp; disconnecting). PWR LED should be on, Charging should be flashing.</li> <li>Hold down BOOT, RST, BOOT sequence. Device will stop disconnecting.</li> <li>Flash Blink Example (SIG LED should begin blinking)</li> <li>3V3 and PWR pins are &gt;2.9V</li> <li>Plug in LiPo, CHG goes solid.</li> <li>Battery pins are &gt;4.00V</li> <li>Analog and Digital Pins should all be floating around the same value 10-50mV.</li> <li>Confirm device still runs on Battery Power once USB is removed.</li> </ul> <p>After this is complete, orders were placed in plastic boxes, with enclosure, USB-C cables, 8pin and 9pin headers, nuts/bolts, and a BOM:</p> <p></p> <p></p> <p></p> <p>Then we put labels on the boxes and wrapped them for delivery!</p> <p></p> <p>Kits were fulfilled the next day! (Note: still need to get some photos of the happy customers!)</p> <p>Enclosure Updates:</p> <p>We've done a bunch of testing and revision to the board enclosures in prep for Revision 2 and our first fulfillment. From our last enclosure we have:</p> <ul> <li>Improve the overall tolerances and fit</li> <li>Added snap tabs to prevent unintentional opening</li> <li>Added M3 Heat-inset Nuts and Machine Bolts</li> <li>Tried out a wide variety of new colors and configurations</li> <li>Added the new multi-color tinyCore logo!</li> <li>Slightly increased the wall thickness</li> </ul> <p>You can see how these revisions turned out:</p> <p></p> <p></p> <p></p> <p></p> <p>So far we have colors in Red, Yellow, Green, Blue, Purple, Black, Grey, and White!</p> <p></p> <p>And, the enclosures still fit with our Expansion module prototypes:</p> <p></p> <p>For a future enclosure revision, I'd still like to:</p> <ul> <li>Add SD Card accessibility</li> <li>Finish adding Buttons (TPU)</li> <li>Add TPU \"Rubber\" feet</li> <li>Experiment with using clear filament for light-pipes.</li> </ul> <p>Outside of these updates...</p> <p>We've got our flyers which we have been sharing around campus:</p> <p></p> <p>And, we've already had people commenting that they've seen the posters, plus we've had quite a lot of QR Code scans so far!</p> <p>We've also been rapidly working on our other expansion board prototypes, and we now have working versions of the tinySniff, tinyDisplay, tinyVoice, tinyGlow, and tinyProto, in various development stages:</p> <ul> <li> <p></p> </li> <li> <p></p> </li> <li> <p></p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul> <p>That's about it for this monthly update, but as a teaser for what's to come, we're excited to announce we're officially started on the </p> <p>Road to Kickstarter.</p>","tags":["orders","fulfillment","PCB","design","marketing","expansions","Devlog"]},{"location":"blog/2024/11/06/esp-now-test/","title":"ESP-NOW Test","text":"<p>Had to find the MAC Addresses of the devices first, so I used this program: </p> <pre><code>#include &lt;WiFi.h&gt;\n#include &lt;esp_wifi.h&gt;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n\n  // Initialize WiFi properly\n  WiFi.mode(WIFI_MODE_APSTA);  // Set to AP+STA mode\n  delay(100);  // Give it some time to initialize\n\n  // Print Station MAC\n  Serial.print(\"Station MAC Address: \");\n  Serial.println(WiFi.macAddress());\n\n  // Print AP MAC\n  Serial.print(\"AP MAC Address: \");\n  Serial.println(WiFi.softAPmacAddress());\n\n  // Additional info about relationship\n  Serial.println(\"\\nTypically, the AP MAC is the Station MAC with\");\n  Serial.println(\"the last byte incremented by 1\");\n}\n\nvoid loop() {\n  // Empty loop\n}\n</code></pre> <p>Then you can use the ESPNOW Serial Example to test coms</p> <p>I set it up to send IMU Data through via the Station device, to the AP device and graph it onto the serial plotter:</p> <p>First, I used the ESP-NOW Serial Example as a basis for checking the ESP-NOW connection:</p> <pre><code>/*\n    ESP-NOW Serial Example - Unicast transmission\n    Lucas Saavedra Vaz - 2024\n    Send data between two ESP32s using the ESP-NOW protocol in one-to-one (unicast) configuration.\n    Note that different MAC addresses are used for different interfaces.\n    The devices can be in different modes (AP or Station) and still communicate using ESP-NOW.\n    The only requirement is that the devices are on the same Wi-Fi channel.\n    Set the peer MAC address according to the device that will receive the data.\n\n    Example setup:\n    - Device 1: AP mode with MAC address F6:12:FA:42:B6:E8\n                Peer MAC address set to the Station MAC address of Device 2 (F4:12:FA:40:64:4C)\n    - Device 2: Station mode with MAC address F4:12:FA:40:64:4C\n                Peer MAC address set to the AP MAC address of Device 1 (F6:12:FA:42:B6:E8)\n\n    The device running this sketch will also receive and print data from any device that has its MAC address set as the peer MAC address.\n    To properly visualize the data being sent, set the line ending in the Serial Monitor to \"Both NL &amp; CR\".\n*/\n\n#include \"ESP32_NOW_Serial.h\"\n#include \"MacAddress.h\"\n#include \"WiFi.h\"\n\n#include \"esp_wifi.h\"\n\n// 0: AP mode, 1: Station mode\n#define ESPNOW_WIFI_MODE_STATION 0\n\n// Channel to be used by the ESP-NOW protocol\n#define ESPNOW_WIFI_CHANNEL 1\n\n#if ESPNOW_WIFI_MODE_STATION          // ESP-NOW using WiFi Station mode\n#define ESPNOW_WIFI_MODE WIFI_STA     // WiFi Mode\n#define ESPNOW_WIFI_IF   WIFI_IF_STA  // WiFi Interface\n#else                                 // ESP-NOW using WiFi AP mode\n#define ESPNOW_WIFI_MODE WIFI_AP      // WiFi Mode\n#define ESPNOW_WIFI_IF   WIFI_IF_AP   // WiFi Interface\n#endif\n\n// Set the MAC address of the device that will receive the data\n// For example: F4:12:FA:40:64:4C\nconst MacAddress peer_mac({0xF0, 0xF5, 0xBD, 0x50, 0xB0, 0x80});\n\nESP_NOW_Serial_Class NowSerial(peer_mac, ESPNOW_WIFI_CHANNEL, ESPNOW_WIFI_IF);\n\nvoid setup() {\n  Serial.begin(115200);\n\n  Serial.print(\"WiFi Mode: \");\n  Serial.println(ESPNOW_WIFI_MODE == WIFI_AP ? \"AP\" : \"Station\");\n  WiFi.mode(ESPNOW_WIFI_MODE);\n\n  Serial.print(\"Channel: \");\n  Serial.println(ESPNOW_WIFI_CHANNEL);\n  WiFi.setChannel(ESPNOW_WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);\n\n  while (!(WiFi.STA.started() || WiFi.AP.started())) {\n    delay(100);\n  }\n\n  Serial.print(\"MAC Address: \");\n  Serial.println(ESPNOW_WIFI_MODE == WIFI_AP ? WiFi.softAPmacAddress() : WiFi.macAddress());\n\n  // Start the ESP-NOW communication\n  Serial.println(\"ESP-NOW communication starting...\");\n  NowSerial.begin(115200);\n  Serial.println(\"You can now send data to the peer device using the Serial Monitor.\\n\");\n}\n\nvoid loop() {\n  while (NowSerial.available()) {\n    Serial.write(NowSerial.read());\n  }\n\n  while (Serial.available() &amp;&amp; NowSerial.availableForWrite()) {\n    if (NowSerial.write(Serial.read()) &lt;= 0) {\n      Serial.println(\"Failed to send data\");\n      break;\n    }\n  }\n\n  delay(1);\n}\n</code></pre> <pre><code>/*\n    ESP-NOW Serial Example - Unicast transmission\n    Lucas Saavedra Vaz - 2024\n    Send data between two ESP32s using the ESP-NOW protocol in one-to-one (unicast) configuration.\n    Note that different MAC addresses are used for different interfaces.\n    The devices can be in different modes (AP or Station) and still communicate using ESP-NOW.\n    The only requirement is that the devices are on the same Wi-Fi channel.\n    Set the peer MAC address according to the device that will receive the data.\n\n    Example setup:\n    - Device 1: AP mode with MAC address F6:12:FA:42:B6:E8\n                Peer MAC address set to the Station MAC address of Device 2 (F4:12:FA:40:64:4C)\n    - Device 2: Station mode with MAC address F4:12:FA:40:64:4C\n                Peer MAC address set to the AP MAC address of Device 1 (F6:12:FA:42:B6:E8)\n\n    The device running this sketch will also receive and print data from any device that has its MAC address set as the peer MAC address.\n    To properly visualize the data being sent, set the line ending in the Serial Monitor to \"Both NL &amp; CR\".\n*/\n\n#include \"ESP32_NOW_Serial.h\"\n#include \"MacAddress.h\"\n#include \"WiFi.h\"\n\n#include \"esp_wifi.h\"\n\n// 0: AP mode, 1: Station mode\n#define ESPNOW_WIFI_MODE_STATION 1\n\n// Channel to be used by the ESP-NOW protocol\n#define ESPNOW_WIFI_CHANNEL 1\n\n#if ESPNOW_WIFI_MODE_STATION          // ESP-NOW using WiFi Station mode\n#define ESPNOW_WIFI_MODE WIFI_STA     // WiFi Mode\n#define ESPNOW_WIFI_IF   WIFI_IF_STA  // WiFi Interface\n#else                                 // ESP-NOW using WiFi AP mode\n#define ESPNOW_WIFI_MODE WIFI_AP      // WiFi Mode\n#define ESPNOW_WIFI_IF   WIFI_IF_AP   // WiFi Interface\n#endif\n\n// Set the MAC address of the device that will receive the data\n// For example: F4:12:FA:40:64:4C\nconst MacAddress peer_mac({0xF2, 0xF5, 0xBD, 0x50, 0xB0, 0x10});\n\nESP_NOW_Serial_Class NowSerial(peer_mac, ESPNOW_WIFI_CHANNEL, ESPNOW_WIFI_IF);\n\nvoid setup() {\n  Serial.begin(115200);\n\n  Serial.print(\"WiFi Mode: \");\n  Serial.println(ESPNOW_WIFI_MODE == WIFI_AP ? \"AP\" : \"Station\");\n  WiFi.mode(ESPNOW_WIFI_MODE);\n\n  Serial.print(\"Channel: \");\n  Serial.println(ESPNOW_WIFI_CHANNEL);\n  WiFi.setChannel(ESPNOW_WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);\n\n  while (!(WiFi.STA.started() || WiFi.AP.started())) {\n    delay(100);\n  }\n\n  Serial.print(\"MAC Address: \");\n  Serial.println(ESPNOW_WIFI_MODE == WIFI_AP ? WiFi.softAPmacAddress() : WiFi.macAddress());\n\n  // Start the ESP-NOW communication\n  Serial.println(\"ESP-NOW communication starting...\");\n  NowSerial.begin(115200);\n  Serial.println(\"You can now send data to the peer device using the Serial Monitor.\\n\");\n}\n\nvoid loop() {\n  while (NowSerial.available()) {\n    Serial.write(NowSerial.read());\n  }\n\n  while (Serial.available() &amp;&amp; NowSerial.availableForWrite()) {\n    if (NowSerial.write(Serial.read()) &lt;= 0) {\n      Serial.println(\"Failed to send data\");\n      break;\n    }\n  }\n\n  delay(1);\n}\n</code></pre> <p>This worked great, and I was able to send characters/messages through Serial Monitor between the devices!</p> <p>Then for the station device, I used Claude to generate an interface which allowed the user to choose between a throughput test, streaming data the IMU, and stopping all actions, based on character commands sent from the AP device. This was the final output of working code:</p> <pre><code>#include \"ESP32_NOW_Serial.h\"\n#include \"MacAddress.h\"\n#include \"WiFi.h\"\n#include \"esp_wifi.h\"\n#include &lt;Adafruit_LSM6DS3TRC.h&gt;\n\n// ESP-NOW Configuration\n#define ESPNOW_WIFI_MODE_STATION 1\n#define ESPNOW_WIFI_CHANNEL 1\n\n#if ESPNOW_WIFI_MODE_STATION\n#define ESPNOW_WIFI_MODE WIFI_STA\n#define ESPNOW_WIFI_IF   WIFI_IF_STA\n#else\n#define ESPNOW_WIFI_MODE WIFI_AP\n#define ESPNOW_WIFI_IF   WIFI_IF_AP\n#endif\n\n// Set your receiver's MAC address here\nconst MacAddress peer_mac({0xF2, 0xF5, 0xBD, 0x50, 0xB0, 0x10});\n\nESP_NOW_Serial_Class NowSerial(peer_mac, ESPNOW_WIFI_CHANNEL, ESPNOW_WIFI_IF);\nAdafruit_LSM6DS3TRC lsm6ds3trc;\n\n// Buffer for formatting IMU data\nchar dataBuffer[100];\n\n// Throughput test variables\nunsigned long startTime;\nunsigned long bytesTransmitted = 0;\nunsigned long packetsTransmitted = 0;\nbool isRunning = false;\nbool inThroughputTest = false;\nconst unsigned long THROUGHPUT_TEST_DURATION = 5000; // 5 seconds test\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Initialize IMU-related pins\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  // Initialize I2C\n  Wire.begin(3, 4);\n  delay(100);\n\n  // Initialize WiFi for ESP-NOW\n  Serial.print(\"WiFi Mode: \");\n  Serial.println(ESPNOW_WIFI_MODE == WIFI_AP ? \"AP\" : \"Station\");\n  WiFi.mode(ESPNOW_WIFI_MODE);\n\n  Serial.print(\"Channel: \");\n  Serial.println(ESPNOW_WIFI_CHANNEL);\n  WiFi.setChannel(ESPNOW_WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);\n\n  while (!(WiFi.STA.started() || WiFi.AP.started())) {\n    delay(100);\n  }\n\n  Serial.print(\"MAC Address: \");\n  Serial.println(ESPNOW_WIFI_MODE == WIFI_AP ? WiFi.softAPmacAddress() : WiFi.macAddress());\n\n  // Initialize ESP-NOW\n  Serial.println(\"ESP-NOW communication starting...\");\n  NowSerial.begin(115200);\n\n  // Initialize LSM6DS3TR-C\n  Serial.println(\"Initializing LSM6DS3TR-C...\");\n  if (!lsm6ds3trc.begin_I2C()) {\n    Serial.println(\"Failed to find LSM6DS3TR-C chip\");\n    while (1) {\n      delay(10);\n    }\n  }\n  Serial.println(\"LSM6DS3TR-C Found!\");\n\n  // Configure IMU settings\n  lsm6ds3trc.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);\n  lsm6ds3trc.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS);\n  lsm6ds3trc.setAccelDataRate(LSM6DS_RATE_104_HZ);\n  lsm6ds3trc.setGyroDataRate(LSM6DS_RATE_104_HZ);\n\n  lsm6ds3trc.configInt1(false, false, true);  // accelerometer DRDY on INT1\n  lsm6ds3trc.configInt2(false, true, false);  // gyro DRDY on INT2\n\n  Serial.println(\"Waiting for command from AP...\");\n  Serial.println(\"Commands:\");\n  Serial.println(\"'s' - Start IMU data transmission\");\n  Serial.println(\"'t' - Run throughput test\");\n  Serial.println(\"'x' - Stop current operation\");\n}\n\nvoid performThroughputTest() {\n  const char testData[] = \"THROUGHPUT_TEST_PACKET\";\n  startTime = millis();\n  bytesTransmitted = 0;\n  packetsTransmitted = 0;\n\n  Serial.println(\"Starting throughput test for 5 seconds...\");\n\n  while (millis() - startTime &lt; THROUGHPUT_TEST_DURATION) {\n    if (NowSerial.availableForWrite()) {\n      // Send test packet\n      for (size_t i = 0; i &lt; strlen(testData); i++) {\n        NowSerial.write(testData[i]);\n      }\n      NowSerial.write('\\n');\n\n      bytesTransmitted += strlen(testData) + 1;  // +1 for newline\n      packetsTransmitted++;\n    }\n\n    // Check for stop command\n    if (NowSerial.available()) {\n      char cmd = NowSerial.read();\n      if (cmd == 'x') {\n        break;\n      }\n    }\n  }\n\n  // Calculate and display results\n  unsigned long duration = millis() - startTime;\n  float throughputKBps = (bytesTransmitted * 1000.0) / (duration * 1024.0);  // KB/s\n  float packetsPerSecond = (packetsTransmitted * 1000.0) / duration;\n\n  Serial.println(\"\\nThroughput Test Results:\");\n  Serial.printf(\"Duration: %lu ms\\n\", duration);\n  Serial.printf(\"Bytes transmitted: %lu\\n\", bytesTransmitted);\n  Serial.printf(\"Packets transmitted: %lu\\n\", packetsTransmitted);\n  Serial.printf(\"Throughput: %.2f KB/s\\n\", throughputKBps);\n  Serial.printf(\"Packets per second: %.2f\\n\", packetsPerSecond);\n\n  inThroughputTest = false;\n}\n\nvoid sendIMUData() {\n  // Read IMU data\n  sensors_event_t accel;\n  sensors_event_t gyro;\n  sensors_event_t temp;\n  lsm6ds3trc.getEvent(&amp;accel, &amp;gyro, &amp;temp);\n\n  // Format the data into a string\n  snprintf(dataBuffer, sizeof(dataBuffer), \"%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\",\n           temp.temperature,\n           accel.acceleration.x,\n           accel.acceleration.y,\n           accel.acceleration.z,\n           gyro.gyro.x,\n           gyro.gyro.y,\n           gyro.gyro.z);\n\n  // Send the data over ESP-NOW\n  if (NowSerial.availableForWrite()) {\n    for (size_t i = 0; i &lt; strlen(dataBuffer); i++) {\n      NowSerial.write(dataBuffer[i]);\n    }\n    NowSerial.write('\\n');\n  }\n\n  // Also print to Serial for debugging\n  Serial.println(dataBuffer);\n}\n\nvoid loop() {\n  // Check for incoming commands\n  while (NowSerial.available()) {\n    char cmd = NowSerial.read();\n\n    switch (cmd) {\n      case 's':\n        if (!isRunning &amp;&amp; !inThroughputTest) {\n          Serial.println(\"Starting IMU data transmission...\");\n          isRunning = true;\n        }\n        break;\n\n      case 't':\n        if (!isRunning &amp;&amp; !inThroughputTest) {\n          inThroughputTest = true;\n          performThroughputTest();\n        }\n        break;\n\n      case 'x':\n        if (isRunning || inThroughputTest) {\n          Serial.println(\"Stopping current operation...\");\n          isRunning = false;\n          inThroughputTest = false;\n        }\n        break;\n    }\n  }\n\n  // Send IMU data if running\n  if (isRunning) {\n    sendIMUData();\n    delay(100);  // Adjust this delay based on your needs\n  }\n}\n</code></pre> <p>After running the throughput test, I got around 57KB/s. This is about 0.46 Mbps!</p> <p>The data also transferred cleanly, and I was able to view it through the serial plotter.</p>  Note: The AP device is still running the example ESP-NOW Serial program in this configuriation.","tags":["testing","example","code","ESP-NOW","MAC","WiFi"]},{"location":"blog/2024/11/06/esp-now-test/#update-112324","title":"Update 11/23/24:","text":"<p>Since adding a custom board library, we no longer need to specify the I2C PWR pins, so these lines have been removed from the example:</p> <pre><code>  // Initialize IMU-related pins\n  ~~pinMode(6, OUTPUT);\n    digitalWrite(6, HIGH);~~\n</code></pre> <p>Also, I2C pins have been written in the board specification, so we can remove those parameters from I2C.begin():</p> <pre><code>  // Initialize I2C\n  Wire.begin(~~3, 4~~);\n  delay(100);\n</code></pre>","tags":["testing","example","code","ESP-NOW","MAC","WiFi"]},{"location":"blog/2024/11/06/i2c-test/","title":"I2C Test","text":"<p>Issues with I2C:</p> <ol> <li>I2C PWR is run on a separate bus for low-power functionality, so you must enable I2C_PWR pin, which is GPIO 6! (Pin 10 on the ESP Module)</li> <li>I2C default pins are 22 and 21, which do not work for our board. We are using pins 3 &amp; 4 for SDA/SCL respectively.</li> </ol> <p>This is what a working setup function looks like:</p> <pre><code>void setup() {\n  pinMode(6, OUTPUT); //Setup the I2C_PWR Pin\n  digitalWrite(6, HIGH); //Turn on the I2C Devices\n  Serial.begin(115200);\n  Wire.begin(3, 4); //Initialize I2C on pins 3 (SDA) and 4 (SCL)\n}\n</code></pre>","tags":["example","code","I2C","IMU"]},{"location":"blog/2024/11/06/i2c-test/#lsm6ds3-imu-test","title":"LSM6DS3 (IMU) Test:","text":"<p>The IMU does not show up right away with the Adafruit example code because it is has the incorrect WHO_AM_I register value: 0x69 (nice) instead of the expected 0x6A (not to be confused with the I2C Address, which is also 0x6A). To fix this, we have to change the Chip ID variable in the Adafruit_LSM6DS3TRC.h file: </p> <pre><code>#define LSM6DS3TRC_CHIP_ID 0x69 ///&lt; LSM6DSL default device id from WHOAMI\n</code></pre> <p>(this is normally set to 0x6A)</p> <p>In the code, we also need to call \"Wire.begin(3, 4)\" before \"lsm6ds3trc.begin_I2C()\" and to set the I2C_PWR pin high:</p> <pre><code>  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  Serial.begin(115200);\n  while (!Serial)\n    delay(10);\n\n  Serial.println(\"Starting I2C initialization...\");\n  Wire.begin(3, 4);\n  delay(100);  // Give I2C time to stabilize\n</code></pre> <p>With this, I was able to get a nice Serial Plotter output in Arduino:</p> <p></p> <p></p> <p>The final working Arduino code: (note that this library file has already had its variables manually updated)</p> <pre><code>// Basic demo for accelerometer/gyro readings from Adafruit LSM6DS3TR-C\n\n#include &lt;Adafruit_LSM6DS3TRC.h&gt;\n\n// For SPI mode, we need a CS pin\n#define LSM_CS 10\n// For software-SPI mode we need SCK/MOSI/MISO pins\n#define LSM_SCK 13\n#define LSM_MISO 12\n#define LSM_MOSI 11\n\nAdafruit_LSM6DS3TRC lsm6ds3trc;\n\nvoid setup(void) {\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  Serial.begin(115200);\n  while (!Serial)\n    delay(10);\n\n  Serial.println(\"Starting I2C initialization...\");\n  Wire.begin(3, 4);\n  delay(100);  // Give I2C time to stabilize\n\n  Serial.println(\"Scanning for I2C devices...\");\n  for (byte address = 1; address &lt; 127; address++) {\n    Wire.beginTransmission(address);\n    byte error = Wire.endTransmission();\n    if (error == 0) {\n      Serial.print(\"I2C device found at address 0x\");\n      if (address &lt; 16) {\n        Serial.print(\"0\");\n      }\n      Serial.println(address, HEX);\n\n      // If this is our LSM6DS3TR-C address, try reading WHO_AM_I register\n      if (address == 0x6A) {\n        Wire.beginTransmission(0x6A);\n        Wire.write(0x0F);  // WHO_AM_I register address\n        Wire.endTransmission(false);\n        Wire.requestFrom(0x6A, 1);\n        if (Wire.available()) {\n          byte whoAmI = Wire.read();\n          Serial.print(\"WHO_AM_I register value: 0x\");\n          Serial.println(whoAmI, HEX);\n          // Should be 0x6A for LSM6DS3TR-C\n        }\n      }\n    }\n  }\n\n  Serial.println(\"Attempting to initialize LSM6DS3TR-C...\");\n  if (!lsm6ds3trc.begin_I2C()) {\n    Serial.println(\"Failed to find LSM6DS3TR-C chip\");\n    Serial.println(\"Check your wiring!\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  Serial.println(\"LSM6DS3TR-C Found!\");\n\n  // lsm6ds3trc.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);\n  Serial.print(\"Accelerometer range set to: \");\n  switch (lsm6ds3trc.getAccelRange()) {\n  case LSM6DS_ACCEL_RANGE_2_G:\n    Serial.println(\"+-2G\");\n    break;\n  case LSM6DS_ACCEL_RANGE_4_G:\n    Serial.println(\"+-4G\");\n    break;\n  case LSM6DS_ACCEL_RANGE_8_G:\n    Serial.println(\"+-8G\");\n    break;\n  case LSM6DS_ACCEL_RANGE_16_G:\n    Serial.println(\"+-16G\");\n    break;\n  }\n\n  // lsm6ds3trc.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS);\n  Serial.print(\"Gyro range set to: \");\n  switch (lsm6ds3trc.getGyroRange()) {\n  case LSM6DS_GYRO_RANGE_125_DPS:\n    Serial.println(\"125 degrees/s\");\n    break;\n  case LSM6DS_GYRO_RANGE_250_DPS:\n    Serial.println(\"250 degrees/s\");\n    break;\n  case LSM6DS_GYRO_RANGE_500_DPS:\n    Serial.println(\"500 degrees/s\");\n    break;\n  case LSM6DS_GYRO_RANGE_1000_DPS:\n    Serial.println(\"1000 degrees/s\");\n    break;\n  case LSM6DS_GYRO_RANGE_2000_DPS:\n    Serial.println(\"2000 degrees/s\");\n    break;\n  case ISM330DHCX_GYRO_RANGE_4000_DPS:\n    break; // unsupported range for the DS33\n  }\n\n  // lsm6ds3trc.setAccelDataRate(LSM6DS_RATE_12_5_HZ);\n  Serial.print(\"Accelerometer data rate set to: \");\n  switch (lsm6ds3trc.getAccelDataRate()) {\n  case LSM6DS_RATE_SHUTDOWN:\n    Serial.println(\"0 Hz\");\n    break;\n  case LSM6DS_RATE_12_5_HZ:\n    Serial.println(\"12.5 Hz\");\n    break;\n  case LSM6DS_RATE_26_HZ:\n    Serial.println(\"26 Hz\");\n    break;\n  case LSM6DS_RATE_52_HZ:\n    Serial.println(\"52 Hz\");\n    break;\n  case LSM6DS_RATE_104_HZ:\n    Serial.println(\"104 Hz\");\n    break;\n  case LSM6DS_RATE_208_HZ:\n    Serial.println(\"208 Hz\");\n    break;\n  case LSM6DS_RATE_416_HZ:\n    Serial.println(\"416 Hz\");\n    break;\n  case LSM6DS_RATE_833_HZ:\n    Serial.println(\"833 Hz\");\n    break;\n  case LSM6DS_RATE_1_66K_HZ:\n    Serial.println(\"1.66 KHz\");\n    break;\n  case LSM6DS_RATE_3_33K_HZ:\n    Serial.println(\"3.33 KHz\");\n    break;\n  case LSM6DS_RATE_6_66K_HZ:\n    Serial.println(\"6.66 KHz\");\n    break;\n  }\n\n  // lsm6ds3trc.setGyroDataRate(LSM6DS_RATE_12_5_HZ);\n  Serial.print(\"Gyro data rate set to: \");\n  switch (lsm6ds3trc.getGyroDataRate()) {\n  case LSM6DS_RATE_SHUTDOWN:\n    Serial.println(\"0 Hz\");\n    break;\n  case LSM6DS_RATE_12_5_HZ:\n    Serial.println(\"12.5 Hz\");\n    break;\n  case LSM6DS_RATE_26_HZ:\n    Serial.println(\"26 Hz\");\n    break;\n  case LSM6DS_RATE_52_HZ:\n    Serial.println(\"52 Hz\");\n    break;\n  case LSM6DS_RATE_104_HZ:\n    Serial.println(\"104 Hz\");\n    break;\n  case LSM6DS_RATE_208_HZ:\n    Serial.println(\"208 Hz\");\n    break;\n  case LSM6DS_RATE_416_HZ:\n    Serial.println(\"416 Hz\");\n    break;\n  case LSM6DS_RATE_833_HZ:\n    Serial.println(\"833 Hz\");\n    break;\n  case LSM6DS_RATE_1_66K_HZ:\n    Serial.println(\"1.66 KHz\");\n    break;\n  case LSM6DS_RATE_3_33K_HZ:\n    Serial.println(\"3.33 KHz\");\n    break;\n  case LSM6DS_RATE_6_66K_HZ:\n    Serial.println(\"6.66 KHz\");\n    break;\n  }\n\n  lsm6ds3trc.configInt1(false, false, true); // accelerometer DRDY on INT1\n  lsm6ds3trc.configInt2(false, true, false); // gyro DRDY on INT2\n}\n\nvoid loop() {\n  // Get a new normalized sensor event\n  sensors_event_t accel;\n  sensors_event_t gyro;\n  sensors_event_t temp;\n  lsm6ds3trc.getEvent(&amp;accel, &amp;gyro, &amp;temp);\n\n//  Serial.print(\"\\t\\tTemperature \");\n//  Serial.print(temp.temperature);\n//  Serial.println(\" deg C\");\n\n  /* Display the results (acceleration is measured in m/s^2) */\n//  Serial.print(\"\\t\\tAccel X: \");\n//  Serial.print(accel.acceleration.x);\n//  Serial.print(\" \\tY: \");\n//  Serial.print(accel.acceleration.y);\n//  Serial.print(\" \\tZ: \");\n//  Serial.print(accel.acceleration.z);\n//  Serial.println(\" m/s^2 \");\n\n  /* Display the results (rotation is measured in rad/s) */\n//  Serial.print(\"\\t\\tGyro X: \");\n//  Serial.print(gyro.gyro.x);\n//  Serial.print(\" \\tY: \");\n//  Serial.print(gyro.gyro.y);\n//  Serial.print(\" \\tZ: \");\n//  Serial.print(gyro.gyro.z);\n//  Serial.println(\" radians/s \");\n//  Serial.println();\n\n  delay(100);\n\n  // serial plotter friendly format\n\n  Serial.print(temp.temperature);\n  Serial.print(\",\");\n\n  Serial.print(accel.acceleration.x);\n  Serial.print(\",\"); Serial.print(accel.acceleration.y);\n  Serial.print(\",\"); Serial.print(accel.acceleration.z);\n  Serial.print(\",\");\n\n  Serial.print(gyro.gyro.x);\n  Serial.print(\",\"); Serial.print(gyro.gyro.y);\n  Serial.print(\",\"); Serial.print(gyro.gyro.z);\n  Serial.println();\n  delayMicroseconds(10000);\n}\n</code></pre>","tags":["example","code","I2C","IMU"]},{"location":"blog/2024/11/24/i2s-audio-test/","title":"I2S Audio Test","text":"<p>I had Claude write up an I2S Test for a speaker, specifically the MAX98357A. Here's the program it wrote:</p> <pre><code>#include &lt;driver/i2s.h&gt;\n\n// I2S pins for ESP32-S3 Feather\n#define I2S_BCLK_PIN       8  // Bit clock\n#define I2S_LRCLK_PIN      9  // Left/Right clock (Word Select)\n#define I2S_DATA_PIN       10  // Data pin\n\n// I2S configuration\n#define SAMPLE_RATE     44100  // Audio sample rate in Hz\n#define BITS_PER_SAMPLE    16  // Bits per sample\n#define CHANNEL_NUM         2  // Number of channels (stereo)\n\n// DMA buffer parameters\n#define DMA_BUF_COUNT      8  // Number of DMA buffers\n#define DMA_BUF_LEN      256  // Size of each DMA buffer\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Configure I2S\n    i2s_config_t i2s_config = {\n        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\n        .sample_rate = SAMPLE_RATE,\n        .bits_per_sample = (i2s_bits_per_sample_t)BITS_PER_SAMPLE,\n        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n        .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n        .dma_buf_count = DMA_BUF_COUNT,\n        .dma_buf_len = DMA_BUF_LEN,\n        .use_apll = false,\n        .tx_desc_auto_clear = true,\n        .fixed_mclk = 0\n    };\n\n    // Configure I2S pins\n    i2s_pin_config_t pin_config = {\n        .mck_io_num = I2S_PIN_NO_CHANGE,\n        .bck_io_num = I2S_BCLK_PIN,\n        .ws_io_num = I2S_LRCLK_PIN,\n        .data_out_num = I2S_DATA_PIN,\n        .data_in_num = I2S_PIN_NO_CHANGE\n    };\n\n    // Install and start I2S driver\n    esp_err_t result = i2s_driver_install(I2S_NUM_0, &amp;i2s_config, 0, NULL);\n    if (result != ESP_OK) {\n        Serial.println(\"Error installing I2S driver\");\n        return;\n    }\n\n    result = i2s_set_pin(I2S_NUM_0, &amp;pin_config);\n    if (result != ESP_OK) {\n        Serial.println(\"Error setting I2S pins\");\n        return;\n    }\n\n    Serial.println(\"I2S initialized successfully\");\n}\n\n// Example function to write a sine wave to I2S\nvoid writeSineWave() {\n    // Generate a 440 Hz sine wave\n    const float frequency = 440.0;  // A4 note\n    const float amplitude = 32000;  // Volume (max is 32767 for 16-bit)\n\n    // Buffer for audio samples\n    int16_t samples[DMA_BUF_LEN * 2];  // *2 for stereo\n\n    static float phase = 0.0;\n    const float phase_increment = 2.0 * PI * frequency / SAMPLE_RATE;\n\n    // Fill the buffer with sine wave samples\n    for (int i = 0; i &lt; DMA_BUF_LEN * 2; i += 2) {\n        int16_t sample = (int16_t)(amplitude * sin(phase));\n        samples[i] = sample;      // Left channel\n        samples[i + 1] = sample;  // Right channel\n\n        phase += phase_increment;\n        if (phase &gt;= 2.0 * PI) {\n            phase -= 2.0 * PI;\n        }\n    }\n\n    // Write the samples to I2S\n    size_t bytes_written;\n    i2s_write(I2S_NUM_0, samples, sizeof(samples), &amp;bytes_written, portMAX_DELAY);\n}\n\nvoid loop() {\n    // Continuously output the sine wave\n    writeSineWave();\n}\n</code></pre> <p>It worked right away! This program will play a 440 Hz tone. </p>  Note: Install the ESP8266 Library before compiling.   <p>I then had Claude update the code to read an MP3 file from the SD Card. Here's the functioning code:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include \"FS.h\"\n#include \"SD.h\"\n#include \"SPI.h\"\n#include &lt;driver/i2s.h&gt;\n#include \"AudioFileSourceSD.h\"\n#include \"AudioFileSourceID3.h\"\n#include \"AudioGeneratorMP3.h\"\n#include \"AudioOutputI2S.h\"\n\n// Pin definitions\n#define I2S_BCLK_PIN       8  // Bit clock\n#define I2S_LRCLK_PIN      9  // Left/Right clock (Word Select)\n#define I2S_DATA_PIN       10  // Data pin\n\n// Audio objects\nAudioFileSourceSD *file;\nAudioFileSourceID3 *id3;\nAudioGeneratorMP3 *mp3;\nAudioOutputI2S *out;\n\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial) {\n        delay(10);\n    }\n    Serial.println(\"Initializing...\");\n\n    // Initialize SD card using the working method\n    if (!SD.begin()) {\n        Serial.println(\"Card Mount Failed\");\n        return;\n    }\n\n    uint8_t cardType = SD.cardType();\n    if (cardType == CARD_NONE) {\n        Serial.println(\"No SD card attached\");\n        return;\n    }\n\n    Serial.print(\"SD Card Type: \");\n    if (cardType == CARD_MMC) {\n        Serial.println(\"MMC\");\n    } else if (cardType == CARD_SD) {\n        Serial.println(\"SDSC\");\n    } else if (cardType == CARD_SDHC) {\n        Serial.println(\"SDHC\");\n    } else {\n        Serial.println(\"UNKNOWN\");\n    }\n\n    // Check if test.mp3 exists\n    if (!SD.exists(\"/test.mp3\")) {\n        Serial.println(\"Can't find /test.mp3\");\n        return;\n    }\n    Serial.println(\"Found test.mp3\");\n\n    // Set up I2S output\n    out = new AudioOutputI2S();\n    out-&gt;SetPinout(I2S_BCLK_PIN, I2S_LRCLK_PIN, I2S_DATA_PIN);\n    out-&gt;SetGain(0.5); // Set volume (0.0-1.0)\n\n    // Set up MP3 decoder\n    file = new AudioFileSourceSD(\"/test.mp3\");\n    id3 = new AudioFileSourceID3(file);\n    mp3 = new AudioGeneratorMP3();\n\n    Serial.println(\"Starting MP3...\");\n    mp3-&gt;begin(id3, out);\n}\n\nvoid loop() {\n    if (mp3-&gt;isRunning()) {\n        if (!mp3-&gt;loop()) {\n            // File is finished playing\n            mp3-&gt;stop();\n            Serial.println(\"MP3 playback completed\");\n            delay(1000);\n\n            // Restart playback\n            Serial.println(\"Restarting playback...\");\n            file-&gt;open(\"/test.mp3\");\n            mp3-&gt;begin(id3, out);\n        }\n    } else {\n        Serial.println(\"MP3 not running, attempting to restart...\");\n        delay(1000);\n        file-&gt;open(\"/test.mp3\");\n        mp3-&gt;begin(id3, out);\n    }\n}\n</code></pre> <p>This one took a few tries, but next I generated some code to record via a microphone and then play it back over the speaker:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include \"FS.h\"\n#include \"SD.h\"\n#include \"SPI.h\"\n#include &lt;driver/i2s.h&gt;\n\n// Pin Definitions\n// Microphone (SPH0645)\n#define I2S_MIC_SCK     8\n#define I2S_MIC_WS      9\n#define I2S_MIC_SD      10\n\n// Speaker\n#define I2S_SPKR_BCLK   8\n#define I2S_SPKR_LRC    9\n#define I2S_SPKR_DIN    10\n\n// Constants for recording\nconst int RECORD_TIME = 5;  // seconds to record\nconst int SAMPLE_RATE = 44100;\nconst int SAMPLE_BITS = 32;\nconst int WAV_HEADER_SIZE = 44;\nconst char* RECORD_FILE = \"/recording.wav\";\nconst int BINARY_BUFFER_SIZE = 1024;\n\n// Global flag to track I2S state\nbool i2s_initialized = false;\n\n// WAV header structure\nstruct WavHeader {\n    char riff[4] = {'R', 'I', 'F', 'F'};\n    uint32_t fileSize = 0;\n    char wave[4] = {'W', 'A', 'V', 'E'};\n    char fmt[4] = {'f', 'm', 't', ' '};\n    uint32_t fmtSize = 16;\n    uint16_t audioFormat = 1;\n    uint16_t numChannels = 1;\n    uint32_t sampleRate = SAMPLE_RATE;\n    uint32_t byteRate = SAMPLE_RATE * 2;\n    uint16_t blockAlign = 2;\n    uint16_t bitsPerSample = 16;\n    char data[4] = {'d', 'a', 't', 'a'};\n    uint32_t dataSize = 0;\n};\n\nvoid cleanup_i2s() {\n    if (i2s_initialized) {\n        i2s_stop(I2S_NUM_0);\n        i2s_driver_uninstall(I2S_NUM_0);\n        i2s_initialized = false;\n        delay(100);\n    }\n}\n\nvoid i2s_mic_init() {\n    cleanup_i2s();\n\n    // Configuration for SPH0645\n    i2s_config_t i2s_config = {\n        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),\n        .sample_rate = SAMPLE_RATE,\n        .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,\n        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,\n        .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n        .dma_buf_count = 4,\n        .dma_buf_len = 1024,\n        .use_apll = false,\n        .tx_desc_auto_clear = false,\n        .fixed_mclk = 0\n    };\n\n    i2s_pin_config_t pin_config = {\n        .mck_io_num = I2S_PIN_NO_CHANGE,\n        .bck_io_num = I2S_MIC_SCK,\n        .ws_io_num = I2S_MIC_WS,\n        .data_out_num = I2S_PIN_NO_CHANGE,\n        .data_in_num = I2S_MIC_SD\n    };\n\n    esp_err_t err = i2s_driver_install(I2S_NUM_0, &amp;i2s_config, 0, NULL);\n    if (err != ESP_OK) {\n        Serial.printf(\"Failed to install I2S driver for mic: %d\\n\", err);\n        return;\n    }\n\n    err = i2s_set_pin(I2S_NUM_0, &amp;pin_config);\n    if (err != ESP_OK) {\n        Serial.printf(\"Failed to set I2S pins for mic: %d\\n\", err);\n        return;\n    }\n\n    i2s_initialized = true;\n    delay(100);\n}\n\nvoid i2s_speaker_init() {\n    cleanup_i2s();\n\n    i2s_config_t i2s_config = {\n        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),\n        .sample_rate = SAMPLE_RATE,\n        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,\n        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,\n        .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n        .dma_buf_count = 8,\n        .dma_buf_len = 1024,\n        .use_apll = false,\n        .tx_desc_auto_clear = true,\n        .fixed_mclk = 0\n    };\n\n    i2s_pin_config_t pin_config = {\n        .mck_io_num = I2S_PIN_NO_CHANGE,\n        .bck_io_num = I2S_SPKR_BCLK,\n        .ws_io_num = I2S_SPKR_LRC,\n        .data_out_num = I2S_SPKR_DIN,\n        .data_in_num = I2S_PIN_NO_CHANGE\n    };\n\n    esp_err_t err = i2s_driver_install(I2S_NUM_0, &amp;i2s_config, 0, NULL);\n    if (err != ESP_OK) {\n        Serial.printf(\"Failed to install I2S driver for speaker: %d\\n\", err);\n        return;\n    }\n\n    err = i2s_set_pin(I2S_NUM_0, &amp;pin_config);\n    if (err != ESP_OK) {\n        Serial.printf(\"Failed to set I2S pins for speaker: %d\\n\", err);\n        return;\n    }\n\n    i2s_initialized = true;\n    delay(100);\n}\n\nvoid writeWavHeader(File file, size_t dataSize) {\n    WavHeader header;\n    header.fileSize = dataSize + WAV_HEADER_SIZE - 8;\n    header.dataSize = dataSize;\n    file.write((const uint8_t*)&amp;header, WAV_HEADER_SIZE);\n}\n\nvoid startRecording() {\n    Serial.println(\"Starting recording...\");\n\n    i2s_mic_init();\n\n    if (!i2s_initialized) {\n        Serial.println(\"Failed to initialize I2S for recording\");\n        return;\n    }\n\n    if (SD.exists(RECORD_FILE)) {\n        SD.remove(RECORD_FILE);\n    }\n\n    File file = SD.open(RECORD_FILE, FILE_WRITE);\n    if (!file) {\n        Serial.println(\"Failed to open file for recording\");\n        return;\n    }\n\n    // Write placeholder header\n    WavHeader header;\n    file.write((const uint8_t*)&amp;header, WAV_HEADER_SIZE);\n\n    size_t bytesWritten = 0;\n    unsigned long startTime = millis();\n    int32_t samples[BINARY_BUFFER_SIZE/4];\n\n    Serial.println(\"Recording...\");\n\n    while ((millis() - startTime) &lt; (RECORD_TIME * 1000)) {\n        size_t bytesRead = 0;\n        esp_err_t result = i2s_read(I2S_NUM_0, samples, sizeof(samples), &amp;bytesRead, portMAX_DELAY);\n\n        if (result == ESP_OK &amp;&amp; bytesRead &gt; 0) {\n            // Process SPH0645 data: 24-bit signed integer in MSB format\n            int16_t converted[BINARY_BUFFER_SIZE/8];\n            for (int i = 0; i &lt; bytesRead/4; i++) {\n                // Convert 24-bit to 16-bit with proper scaling\n                converted[i] = (int16_t)(samples[i] &gt;&gt; 14);\n            }\n            file.write((const uint8_t*)converted, bytesRead/2);\n            bytesWritten += bytesRead/2;\n        }\n    }\n\n    // Update WAV header with final size\n    file.seek(0);\n    writeWavHeader(file, bytesWritten);\n    file.close();\n\n    cleanup_i2s();\n    Serial.println(\"Recording finished!\");\n}\n\nvoid playRecording() {\n    Serial.println(\"Playing recording...\");\n\n    // Initialize speaker\n    i2s_speaker_init();\n    if (!i2s_initialized) {\n        Serial.println(\"Failed to initialize I2S for playback\");\n        return;\n    }\n\n    // Open WAV file\n    File file = SD.open(RECORD_FILE);\n    if (!file) {\n        Serial.println(\"Failed to open file for playback\");\n        return;\n    }\n\n    // Skip WAV header\n    file.seek(WAV_HEADER_SIZE);\n\n    // Read and play file\n    uint8_t buffer[1024];\n    size_t bytes_read;\n    Serial.println(\"Starting playback...\");\n\n    while (file.available()) {\n        bytes_read = file.read(buffer, sizeof(buffer));\n        if (bytes_read &gt; 0) {\n            size_t bytes_written = 0;\n\n            // Amplify the signal\n            int16_t *samples = (int16_t*)buffer;\n            for(int i=0; i &lt; bytes_read/2; i++) {\n              samples[i] = samples[i] * 4;  // Multiply by 2-8 for more volume\n            }\n\n            esp_err_t result = i2s_write(I2S_NUM_0, buffer, bytes_read, &amp;bytes_written, portMAX_DELAY);\n            if (result != ESP_OK) {\n                Serial.printf(\"Failed to write I2S data: %d\\n\", result);\n            }\n        }\n    }\n\n    file.close();\n    cleanup_i2s();\n    Serial.println(\"Playback finished!\");\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial) delay(10);\n\n    Serial.println(\"Initializing...\");\n\n    // Initialize SD card\n    if (!SD.begin()) {\n        Serial.println(\"Card Mount Failed\");\n        return;\n    }\n\n    // Make sure I2S is clean at startup\n    cleanup_i2s();\n\n    Serial.println(\"Ready! Send 'R' to start recording.\");\n}\n\nvoid loop() {\n    if (Serial.available()) {\n        char cmd = Serial.read();\n        if (cmd == 'R' || cmd == 'r') {\n            startRecording();\n            delay(500);\n            playRecording();\n        }\n    }\n}\n</code></pre> <p>And it works great! I'm able to record a short message and play it back over the speaker!</p>","tags":["example","code","I2S","Audio"]},{"location":"blog/2024/11/23/sd-card-test/","title":"SD Card Test","text":"<p>Finally got the SD Card working! Turns out the CS Pin is connected to GPIO1, not GPIO2, due to a pin mix-up in the library. Simple software fix, and it's like magic!</p> <p>Also, I would recommend verifying that you don't have a corrupted Chinese-knockoff SD Card, as this will also cause you headaches and make things more difficult to solve.</p> <p>For the SD test, we actually used the Arduino SD_Test Example, which worked out of the box (with our custom board library):</p> <pre><code>void listDir(fs::FS &amp;fs, const char *dirname, uint8_t levels) {\n  Serial.printf(\"Listing directory: %s\\n\", dirname);\n\n  File root = fs.open(dirname);\n  if (!root) {\n    Serial.println(\"Failed to open directory\");\n    return;\n  }\n  if (!root.isDirectory()) {\n    Serial.println(\"Not a directory\");\n    return;\n  }\n\n  File file = root.openNextFile();\n  while (file) {\n    if (file.isDirectory()) {\n      Serial.print(\"  DIR : \");\n      Serial.println(file.name());\n      if (levels) {\n        listDir(fs, file.path(), levels - 1);\n      }\n    } else {\n      Serial.print(\"  FILE: \");\n      Serial.print(file.name());\n      Serial.print(\"  SIZE: \");\n      Serial.println(file.size());\n    }\n    file = root.openNextFile();\n  }\n}\n\nvoid createDir(fs::FS &amp;fs, const char *path) {\n  Serial.printf(\"Creating Dir: %s\\n\", path);\n  if (fs.mkdir(path)) {\n    Serial.println(\"Dir created\");\n  } else {\n    Serial.println(\"mkdir failed\");\n  }\n}\n\nvoid removeDir(fs::FS &amp;fs, const char *path) {\n  Serial.printf(\"Removing Dir: %s\\n\", path);\n  if (fs.rmdir(path)) {\n    Serial.println(\"Dir removed\");\n  } else {\n    Serial.println(\"rmdir failed\");\n  }\n}\n\nvoid readFile(fs::FS &amp;fs, const char *path) {\n  Serial.printf(\"Reading file: %s\\n\", path);\n\n  File file = fs.open(path);\n  if (!file) {\n    Serial.println(\"Failed to open file for reading\");\n    return;\n  }\n\n  Serial.print(\"Read from file: \");\n  while (file.available()) {\n    Serial.write(file.read());\n  }\n  file.close();\n}\n\nvoid writeFile(fs::FS &amp;fs, const char *path, const char *message) {\n  Serial.printf(\"Writing file: %s\\n\", path);\n\n  File file = fs.open(path, FILE_WRITE);\n  if (!file) {\n    Serial.println(\"Failed to open file for writing\");\n    return;\n  }\n  if (file.print(message)) {\n    Serial.println(\"File written\");\n  } else {\n    Serial.println(\"Write failed\");\n  }\n  file.close();\n}\n\nvoid appendFile(fs::FS &amp;fs, const char *path, const char *message) {\n  Serial.printf(\"Appending to file: %s\\n\", path);\n\n  File file = fs.open(path, FILE_APPEND);\n  if (!file) {\n    Serial.println(\"Failed to open file for appending\");\n    return;\n  }\n  if (file.print(message)) {\n    Serial.println(\"Message appended\");\n  } else {\n    Serial.println(\"Append failed\");\n  }\n  file.close();\n}\n\nvoid renameFile(fs::FS &amp;fs, const char *path1, const char *path2) {\n  Serial.printf(\"Renaming file %s to %s\\n\", path1, path2);\n  if (fs.rename(path1, path2)) {\n    Serial.println(\"File renamed\");\n  } else {\n    Serial.println(\"Rename failed\");\n  }\n}\n\nvoid deleteFile(fs::FS &amp;fs, const char *path) {\n  Serial.printf(\"Deleting file: %s\\n\", path);\n  if (fs.remove(path)) {\n    Serial.println(\"File deleted\");\n  } else {\n    Serial.println(\"Delete failed\");\n  }\n}\n\nvoid testFileIO(fs::FS &amp;fs, const char *path) {\n  File file = fs.open(path);\n  static uint8_t buf[512];\n  size_t len = 0;\n  uint32_t start = millis();\n  uint32_t end = start;\n  if (file) {\n    len = file.size();\n    size_t flen = len;\n    start = millis();\n    while (len) {\n      size_t toRead = len;\n      if (toRead &gt; 512) {\n        toRead = 512;\n      }\n      file.read(buf, toRead);\n      len -= toRead;\n    }\n    end = millis() - start;\n    Serial.printf(\"%u bytes read for %lu ms\\n\", flen, end);\n    file.close();\n  } else {\n    Serial.println(\"Failed to open file for reading\");\n  }\n\n  file = fs.open(path, FILE_WRITE);\n  if (!file) {\n    Serial.println(\"Failed to open file for writing\");\n    return;\n  }\n\n  size_t i;\n  start = millis();\n  for (i = 0; i &lt; 2048; i++) {\n    file.write(buf, 512);\n  }\n  end = millis() - start;\n  Serial.printf(\"%u bytes written for %lu ms\\n\", 2048 * 512, end);\n  file.close();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  while (!Serial) {\n    delay(10);\n  }\n\n#ifdef REASSIGN_PINS\n  SPI.begin(sck, miso, mosi, cs);\n  if (!SD.begin(cs)) {\n#else\n  if (!SD.begin()) {\n#endif\n    Serial.println(\"Card Mount Failed\");\n    return;\n  }\n  uint8_t cardType = SD.cardType();\n\n  if (cardType == CARD_NONE) {\n    Serial.println(\"No SD card attached\");\n    return;\n  }\n\n  Serial.print(\"SD Card Type: \");\n  if (cardType == CARD_MMC) {\n    Serial.println(\"MMC\");\n  } else if (cardType == CARD_SD) {\n    Serial.println(\"SDSC\");\n  } else if (cardType == CARD_SDHC) {\n    Serial.println(\"SDHC\");\n  } else {\n    Serial.println(\"UNKNOWN\");\n  }\n\n  uint64_t cardSize = SD.cardSize() / (1024 * 1024);\n  Serial.printf(\"SD Card Size: %lluMB\\n\", cardSize);\n\n  listDir(SD, \"/\", 0);\n  createDir(SD, \"/mydir\");\n  listDir(SD, \"/\", 0);\n  removeDir(SD, \"/mydir\");\n  listDir(SD, \"/\", 2);\n  writeFile(SD, \"/hello.txt\", \"Hello \");\n  appendFile(SD, \"/hello.txt\", \"World!\\n\");\n  readFile(SD, \"/hello.txt\");\n  deleteFile(SD, \"/foo.txt\");\n  renameFile(SD, \"/hello.txt\", \"/foo.txt\");\n  readFile(SD, \"/foo.txt\");\n  testFileIO(SD, \"/test.txt\");\n  Serial.printf(\"Total space: %lluMB\\n\", SD.totalBytes() / (1024 * 1024));\n  Serial.printf(\"Used space: %lluMB\\n\", SD.usedBytes() / (1024 * 1024));\n}\n\nvoid loop() {}\n</code></pre> <p>I then updated this with the IMU code, and created a basic motion datalogger device:</p> <pre><code>#include &lt;Adafruit_LSM6DS3TRC.h&gt;\n#include \"FS.h\"\n#include \"SD.h\"\n#include \"SPI.h\"\n\nAdafruit_LSM6DS3TRC lsm6ds3trc;\nFile dataFile;\nconst char* DATA_FILENAME = \"/imu_data.txt\";\nunsigned long lastLogTime = 0;\nconst unsigned long LOG_INTERVAL = 25; // Log every 25ms\n\nvoid setup() {\n  Serial.begin(115200);\n  while (!Serial) {\n    delay(10);\n  }\n\n  // Initialize I2C\n  Wire.begin();\n  delay(100);\n\n  // Initialize SD card\n  if (!SD.begin()) {\n    Serial.println(\"Card Mount Failed\");\n    return;\n  }\n\n  uint8_t cardType = SD.cardType();\n  if (cardType == CARD_NONE) {\n    Serial.println(\"No SD card attached\");\n    return;\n  }\n\n  Serial.print(\"SD Card Type: \");\n  if (cardType == CARD_MMC) {\n    Serial.println(\"MMC\");\n  } else if (cardType == CARD_SD) {\n    Serial.println(\"SDSC\");\n  } else if (cardType == CARD_SDHC) {\n    Serial.println(\"SDHC\");\n  } else {\n    Serial.println(\"UNKNOWN\");\n  }\n\n  // Initialize LSM6DS3TR-C\n  Serial.println(\"Initializing LSM6DS3TR-C...\");\n  if (!lsm6ds3trc.begin_I2C()) {\n    Serial.println(\"Failed to find LSM6DS3TR-C chip\");\n    while (1) {\n      delay(10);\n    }\n  }\n  Serial.println(\"LSM6DS3TR-C Found!\");\n\n  // Configure IMU settings\n  lsm6ds3trc.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);\n  lsm6ds3trc.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS);\n  lsm6ds3trc.setAccelDataRate(LSM6DS_RATE_104_HZ);\n  lsm6ds3trc.setGyroDataRate(LSM6DS_RATE_104_HZ);\n\n  // Create/Open data file and write header\n  dataFile = SD.open(DATA_FILENAME, FILE_WRITE);\n  if (!dataFile) {\n    Serial.println(\"Failed to open data file\");\n    return;\n  }\n\n  // Write CSV header\n  dataFile.println(\"timestamp,temperature,accel_x,accel_y,accel_z,gyro_x,gyro_y,gyro_z\");\n  dataFile.flush();\n\n  Serial.println(\"Logging started!\");\n  Serial.println(\"Format: timestamp,temperature,accel_x,accel_y,accel_z,gyro_x,gyro_y,gyro_z\");\n}\n\nvoid logIMUData() {\n  sensors_event_t accel;\n  sensors_event_t gyro;\n  sensors_event_t temp;\n  lsm6ds3trc.getEvent(&amp;accel, &amp;gyro, &amp;temp);\n\n  // Format data string\n  char dataString[100];\n  snprintf(dataString, sizeof(dataString), \n           \"%lu,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\",\n           millis(),\n           temp.temperature,\n           accel.acceleration.x,\n           accel.acceleration.y,\n           accel.acceleration.z,\n           gyro.gyro.x,\n           gyro.gyro.y,\n           gyro.gyro.z);\n\n  // Write to SD card\n  dataFile.println(dataString);\n  dataFile.flush();  // Ensure data is written to card\n\n  // Also print to Serial for monitoring\n  Serial.println(dataString);\n}\n\nvoid loop() {\n  unsigned long currentTime = millis();\n\n  // Log data at specified interval\n  if (currentTime - lastLogTime &gt;= LOG_INTERVAL) {\n    logIMUData();\n    lastLogTime = currentTime;\n  }\n}\n</code></pre> <p>This program records movement data every 25ms and writes it to the SD Card. I tested opening the test file it creates in Excel as a CSV, and the results are fantastic:</p> timestamp (ms) temperature accel_x accel_y accel_z gyro_x gyro_y gyro_z 940 24.98 0.17 0.05 9.86 0.03 -0.06 -0.05 964 24.97 0.19 0.06 9.85 0.03 -0.06 -0.05 989 24.97 0.21 0.07 9.85 0.03 -0.06 -0.05 1014 24.98 0.18 0.07 9.85 0.03 -0.06 -0.05 1039 24.98 0.2 0.06 9.85 0.03 -0.06 -0.05 1064 24.98 0.19 0.06 9.86 0.03 -0.06 -0.05 1089 24.98 0.17 0.07 9.85 0.03 -0.06 -0.05 1114 24.98 0.18 0.07 9.86 0.03 -0.06 -0.05 1139 24.98 0.2 0.07 9.86 0.03 -0.06 -0.05 1164 24.98 0.2 0.07 9.86 0.03 -0.06 -0.05 ... ... ... ... ... ... ... ...  Note that the Z axis is experiencing 9.81 m/s^2 of acceleration, which is due to gravity!  <p></p>","tags":["example","code","IMU","SD"]},{"location":"blog/2025/03/23/weeknotes-1/","title":"Weeknotes #1","text":"<p>We're changing up our Devnotes to from monthly to weekly updates! The goal of this is to promote \"working with the garage door open,\" giving (you) our followers the inside scoop on our progress and decisions. Let's get into the weeknote:</p> <p>This week was crazy! For starters, we released a 2 minute teaser for the tinyCore, and it blew up! (at least for us). It's currently standing at just over 2k views! You can check it out here if you missed it: https://youtu.be/wqKJGHjnWzM</p> <p>And speaking of my best friend Aiden, he posted his first YouTube video this week! And it features the tinyCore! He's designed a custom LED controller HAT, and put together a heckin' awesome cyberpunk-inspired light-up jacket. Be sure to check it out here:</p> <p>https://www.youtube.com/watch?v=YYvXN1_iXFg&amp;ab_channel=GalahadGear</p> <p>As for orders, we began offering shipping in the US this week on our website, and we've started taking our next batch of pre-orders. Our current production run completed fabrication this week and is currently in assembly, with 100 units slated to arrive by April 5<sup>th</sup>!</p> <p>Aside from hardware, we've also gone through and begun revising ALL of our documentation. (The main piece of feedback was that we needed more.)</p> <p>So we've revamped the ENTIRE GitHub Repo, overhauled the README.md, reorganized our file structures, added Datasheets for all major components, and begun our first draft of the tinyCore Datasheet!</p> <p>https://github.com/Mister-Industries/tinyCore</p> <p>I'm particularly proud of the Pinout graphic (that took me hours to create):</p> <p></p> <p>By no means is this documentation finished, but we hope these updates will help you understand our kit better!</p> <p>Oh, and also it's Spring Break now! So the next week should see a lot of progress, since I don't have homework.</p> <p>Looking ahead, we're going to continue work on our project documentation and YouTube presence, and we will be presenting our project at a few events! Namely:</p> <ul> <li>Clear Creek Makerspace Anniversary Celebration - 3/31</li> <li>Mines Entrepreneurship Summit - 4/16</li> <li>CU Boulder Engineering Expo - 4/25</li> <li>ATLAS Expo - 5/1</li> </ul> <p>We're very excited to meet with more students and see what people build with tinyCore! Hope to see you there!</p>","tags":["Weeknotes","tinyGlow","Pinout","Events"]},{"location":"blog/2025/04/02/weeknotes-2/","title":"Weeknotes #2","text":"<p>Hey everyone! Welcome to this week's Wednesday Weeknote. Here's what we've been up to:</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/02/weeknotes-2/#highlights","title":"\ud83d\udd25 Highlights","text":"<ul> <li>Sexy new documentation website</li> <li>Presented at the 20<sup>th</sup> Anniversary Celebration for Clear Creek Makerspace</li> <li>Applied to the Underdogs Grant fund by MatrixOwl</li> <li>Hand-delivered a tinyCore V2 Starter Kit to a certain YouTuber </li> <li>Our latest shipment of PCBs as arrived! (Next up: Testinggg)</li> </ul>","tags":["Weeknotes"]},{"location":"blog/2025/04/02/weeknotes-2/#hardware-updates","title":"Hardware Updates","text":"<p>tinyCore is now officially OSHWA certified! Aside from getting access to a neat logo for our silkscreen, this also means our little board meets all of OSHWA's rigorous open-source hardware standards, certifying that everyone has the freedom to hack, modify, and build upon our design.</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/02/weeknotes-2/#software-documentation","title":"Software &amp; Documentation","text":"<p>As you can probably tell since you're reading this weeknote.. We have a new docs website (with a sexy new subdomain too)! </p> <p></p> <p>This site will be the home for all of our new documentation and weeknotes moving forward. It's still under construction, but we will be working rapidly to fill out tutorials, datasheets, how-to's and more!</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/02/weeknotes-2/#production-fulfillment","title":"Production &amp; Fulfillment","text":"<p>Our first batch of new boards has arrived, and just in-time to miss some fun changes by our current administration. </p> <p>The boards look great. We've successfully powered-up and flashed the first unit, which is now ready to be shipped!</p> <ul> <li> <p></p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul> <p>As the rest of our KoP<sup>1</sup> makes it's way through lead-time, we're quickly beginning to ramp up our testing efforts with a custom rig, to standardize our procedures and process units rapidly. All of this will be documented in the open for learning purposes!</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/02/weeknotes-2/#community-marketing","title":"Community &amp; Marketing","text":"<p>This week was the 20<sup>th</sup> Anniversary of LocalWorks, the managers of Clear Creek Makerspace. They extended us an invitation to present our project which we gratefully accepted! And the community really liked it! </p> <p>Here's some photos of our \"booth\" from the event. It was great to meet everyone, show off some of our student projects, and make the first irl debut of tinyCore!</p> <ul> <li> <p></p> </li> <li> <p></p> </li> </ul> <ul> <li> <p></p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul>","tags":["Weeknotes"]},{"location":"blog/2025/04/02/weeknotes-2/#events-opportunities","title":"Events &amp; Opportunities","text":"<p>If you'd like to meet us in-person, we've got several events coming up that we are scheduled to attend:</p> <ul> <li>Mines Entrepreneurship Summit - 4/16</li> <li>CU Boulder Engineering Expo - 4/25</li> <li>ATLAS Expo - 5/1</li> </ul> <p>And we've currently applied to visit:</p> <ul> <li>Open Hardware Summit in Edinburgh- 5/30</li> <li>Open Sauce 2025- 7/18</li> </ul> <p>We're also actively working on our submission to the Hackster.io Board Design Competition, and will update you shortly on progress.</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/02/weeknotes-2/#whats-next","title":"What's Next","text":"<ul> <li>Testing, soldering, and more testing </li> <li>Fulfillment of our first pre-orders! </li> <li>Continued development of our documentation</li> </ul> <p>We're trying a new style with the format of these weeknotes with MkDocs. As always, we'd love your feedback, and we've made it easier than ever to share! Drop us a comment below with your thoughts, projects, or questions!</p> <ol> <li> <p>Kit of Parts\u00a0\u21a9</p> </li> </ol>","tags":["Weeknotes"]},{"location":"blog/2025/04/17/weeknotes-3/","title":"Weeknotes #3","text":"<p>In the face of midterms and final projects, we continued to make progress on tinyCore! Here's what happened this week:</p> <ul> <li>Began testing V2.1 PCBs</li> <li>Attended First Pitch Colorado</li> <li>Met with more professors for our Fall Cohort</li> <li>Presented tinyCore at the Mines Entrepreneurship</li> <li>Showcase</li> <li>Shipped our first online orders</li> <li>GOT ACCEPTED FOR OPEN SAUCE!!</li> </ul>","tags":["Weeknotes"]},{"location":"blog/2025/04/17/weeknotes-3/#production-fulfillment","title":"Production &amp; Fulfillment","text":"<p>This week we started testing our new V2.1 PCBs and started shipping pre-orders. Our first board was mailed just this past Wednesday! We\u2019re actively developing our testing procedure, but here\u2019s what we have so far:</p> <pre><code>1. Inspect Silkscreen for Quality and visual errors\n2. Connect to PC via USB (It should be recognized as a generic ESP32 device, and will be connecting &amp; disconnecting). \n3. PWR LED should be on, CHG LED should be flashing.\n4. Plug in LiPo Battery, CHG goes solid.\n5. Hold down BOOT, RST, BOOT sequence. Device will stop disconnecting.\n6. Flash Blink Example (SIG LED should begin blinking)\n7. 3V3 and PWR pins are &gt;3.29V\n8. Battery pins are &gt;4.00V\n9. Analog and Digital Pins should all be floating around the same value 10-50mV.\n10. TX, SDA, SCL are all pulled high (&gt;3.29V) by default\n11. Device still runs on Battery Power once USB is removed.\n</code></pre> <p>We\u2019d love your feedback on this procedure (comment thoughts below). To help with testing, Aiden is also actively designing a custom bed-of-nails testbench, powered by tinyCore of course!</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/17/weeknotes-3/#community-marketing","title":"Community &amp; Marketing","text":"<p>Aside from testing, we really focused on our marketing presence this week. We attended multiple networking events and I was overwhelmed by the amount of positive support and feedback we got from our in-person demos. We attended First Pitch Colorado, put on by Tim Morrisey, and presented at Mines Entrepreneurship Showcase --where we met with students, professors, and startup founders. There, we showed off all the cool projects students have built so far with tinyCore.</p> <ul> <li> <p></p> <p>The first exhibition of Punch-It! (Like Bop-It, but more violent)</p> </li> <li> <p></p> <p>Followed by the SECOND exhibition of Punch-It!</p> </li> </ul> <p>Made by Logan B. - Computer Science major, CU Boulder</p> <ul> <li> <p></p> <p>Users interacting with the student-made VINE BOOM button</p> </li> <li> <p></p> <p>This one sparks joy</p> </li> </ul> <p>Made by Elior B. - Mechanical Engineering major, Mines</p> <ul> <li> <p></p> <p>Aiden explains the Ski-Safe Alert Helmet </p> </li> <li> <p></p> <p>Geoff copies Aiden</p> </li> </ul> <p>Made by Elizabeth S. - Creative Technology and Design major, CU Boulder</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/17/weeknotes-3/#events-opportunities","title":"Events &amp; Opportunities","text":"<p>Oh yeah, and last but not least, this email ended up in our inbox\u2026</p> <p></p> <p>So we\u2019re OFFICIALLY PRESENTING AT OPEN SAUCE!!</p> <p>We\u2019re so excited. To celebrate, I thought I\u2019d share our winning crayon-drawing entry (required by OS): </p> <p>You can expect to see something like this at our booth in July! Although it\u2019ll probably look a bit more realistic..</p>","tags":["Weeknotes"]},{"location":"blog/2025/04/17/weeknotes-3/#whats-next","title":"What's Next","text":"<p>But we're not stopping here. We've got a lot more work to do (aside from graduating), so it's time to get back to work. Here's the agenda for next week:</p> <ol> <li> <p>Continue Testing and Kitting</p> </li> <li> <p>Build out our core documentation (#KickassSupport)</p> </li> <li> <p>Present our project at CU Senior Design Expo</p> </li> <li> <p>Follow-up meetings with professors and founders from networking.</p> </li> </ol> <p>As always, we'd love your feedback, and we've made it easier than ever to contribute! Drop us a comment below with your thoughts, projects, or questions!</p>","tags":["Weeknotes"]},{"location":"blog/2025/05/07/weeknotes-4/","title":"Weeknotes #4","text":"<p>If you're keeping count, you'll noticed we missed last week, and that's because we're still a student-run company (until next semester). However, with finals over, we've got a bunch of good updates to share! Here's what happened this week (and last):</p> <ul> <li>Presented tinyCore via OpenHEG during CU Boulder's Senior Engineering Expo</li> <li>Shared our project at CU's ATLAS Expo</li> <li>Made some banger new business cards</li> <li>Sold and tested more kits</li> <li>Refined our Kit of Parts (now with a sweet treat)</li> <li>Won a 9k Microgrant from Clear Creek Makerspace!</li> <li>Begun editing our \"How it's made - tinyCore\" Video</li> </ul>","tags":["Weeknotes"]},{"location":"blog/2025/05/07/weeknotes-4/#production-fulfillment","title":"Production &amp; Fulfillment","text":"<p>We've updated our Kit of Parts to now include a secret sweet treat... Gummy bears! Taking inspiration from Prusa, we wanted to include a small token of gratitude with each of our initial orders. It fits our company mission of Kickass Support and striving for excellence, plus it tastes good!  </p> <p></p>","tags":["Weeknotes"]},{"location":"blog/2025/05/07/weeknotes-4/#community-marketing","title":"Community &amp; Marketing","text":"<p>The last two weeks included more marketing and community-building! Our two main events were Capstone (Senior Design) Expo and ATLAS Expo. We got lots of great shots, some of which I'd like to share. But before that, check out our awesome new business cards:</p> <p></p> <p>They're a 1-1 scale so customers can test-fit their projects before they buy! It's quite convincing too, several people at ATLAS Expo didn't realize they weren't the real thing!</p> <p>Demo-ing OpenHEG (a project build with tinyCore) at CU Boulder's Senior Design Expo</p> <p>And our booth at ATLAS Expo:</p> <ul> <li> <p></p> <p>Demo-ing the Punch-It! to it's intended user</p> </li> <li> <p></p> <p>Positive market validation testing</p> </li> </ul> <p>Made by Logan B. - Computer Science major, CU Boulder</p> <p>And in the project spotlight this week, is a project made by Keaton, a smart-LED graduation cap! He even made it on the CU Boulder Engineering Instagram! I think this is one of the most professional builds I've seen so far with tinyCore. Congrats Keaton!</p> <ul> <li> <p></p> <p>Demo of a smart graduation cap, built with tinyGlow</p> </li> <li> <p></p> <p>Turns out Tetris is hard..</p> </li> </ul> <p>Made by Keaton G. - Computer Science major, CU Boulder</p>","tags":["Weeknotes"]},{"location":"blog/2025/05/07/weeknotes-4/#events-opportunities","title":"Events &amp; Opportunities","text":"<p>To be honest, it seems like the events are never going to stop... but that's a good thing! Up next, we have Boulder Startup Week (May 12-16<sup>th</sup>), and then we're actively preparing for Open Sauce in July. We will keep you posted with progress as we design our booth.</p>","tags":["Weeknotes"]},{"location":"blog/2025/05/07/weeknotes-4/#whats-next","title":"What's Next","text":"<p>Same as last week, there's always more work to do. Here's the agenda for next week:</p> <ol> <li> <p>Test and Kit our next batch of orders</p> </li> <li> <p>Build out our core documentation (#KickassSupport)</p> </li> <li> <p>Finish our how-we-made-it YouTube video</p> </li> <li> <p>List our product on Tindie marketplace!</p> </li> </ol> <p>As always, we'd love your feedback, and we've made it easier than ever to contribute! Drop us a comment below with your thoughts, projects, or questions!</p>","tags":["Weeknotes"]},{"location":"deep-dive/","title":"Deep Dive","text":""},{"location":"deep-dive/#this-zone-is-under-construction","title":"THIS ZONE IS UNDER CONSTRUCTION","text":""},{"location":"deep-dive/imu/","title":"Imu","text":""},{"location":"deep-dive/imu/#advanced-concepts","title":"Advanced Concepts:","text":""},{"location":"deep-dive/imu/#thresholding","title":"Thresholding:","text":"<p>Sometimes we want to remove noise from our measurements to detect a specific action or motion. The easiest way to do this is thresholding. Here\u2019s the program I\u2019ve setup:</p> <p>IMU-Serial-Plotter-Thresholding.ino</p> <pre><code>#include &lt;tinyCore_LSM6DS3TRC.h&gt;\n\ntinyCore_LSM6DS3TRC lsm6ds3trc;\nunsigned long lastSampleTime = 0;\nconst unsigned long SAMPLE_INTERVAL = 25; // Sample every 25ms\n\n// Z-axis threshold parameters (in m/s^2)\nfloat Z_THRESHOLD_MIN = -5.0;  // Minimum threshold \nfloat Z_THRESHOLD_MAX = 5.0;   // Maximum threshold\nint thresholdState = 0;        // Current threshold state (0 or 1)\n\nvoid setup() {\n  Serial.begin(115200);\n  /* while (!Serial) {\n    delay(10);\n  }*/\n\n  // Initialize IMU-related pins\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  // Initialize I2C\n  Wire.begin(3, 4);\n  delay(100);\n\n  Serial.println(\"Scanning for I2C devices...\");\n  for (byte address = 1; address &lt; 127; address++) {\n    Wire.beginTransmission(address);\n    byte error = Wire.endTransmission();\n    if (error == 0) {\n      Serial.print(\"I2C device found at address 0x\");\n      if (address &lt; 16) {\n        Serial.print(\"0\");\n      }\n      Serial.println(address, HEX);\n\n      // If this is our LSM6DS3TR-C address, try reading WHO_AM_I register\n      if (address == 0x6A) {\n        Wire.beginTransmission(0x6A);\n        Wire.write(0x0F); // WHO_AM_I register address\n        Wire.endTransmission(false);\n        Wire.requestFrom(0x6A, 1);\n        if (Wire.available()) {\n          byte whoAmI = Wire.read();\n          Serial.print(\"WHO_AM_I register value: 0x\");\n          Serial.println(whoAmI, HEX); // Should be 0x6A for LSM6DS3TR-C\n        }\n      }\n    }\n  }\n\n  Serial.println(\"Attempting to initialize LSM6DS3TR-C...\");\n  if (!lsm6ds3trc.begin_I2C()) {\n    Serial.println(\"Failed to find LSM6DS3TR-C chip\");\n    Serial.println(\"Check your wiring!\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  Serial.println(\"LSM6DS3TR-C Found!\");\n\n  // Configure IMU settings\n  lsm6ds3trc.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);\n  lsm6ds3trc.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS);\n  lsm6ds3trc.setAccelDataRate(LSM6DS_RATE_104_HZ);\n  lsm6ds3trc.setGyroDataRate(LSM6DS_RATE_104_HZ);\n\n  // Print labels for Serial Plotter\n  Serial.println(\"AccelZ:ThresholdMin:ThresholdMax:ThresholdState\");\n}\n\nvoid sampleIMUData() {\n  sensors_event_t accel;\n  sensors_event_t gyro;\n  sensors_event_t temp;\n\n  lsm6ds3trc.getEvent(&amp;accel, &amp;gyro, &amp;temp);\n\n  // Get Z-axis acceleration\n  float accelZ = accel.acceleration.z;\n\n  // Determine threshold state (1 if within thresholds, 0 if outside)\n  if (accelZ &gt;= Z_THRESHOLD_MIN &amp;&amp; accelZ &lt;= Z_THRESHOLD_MAX) {\n    thresholdState = 0;  // Within threshold range (not triggered)\n  } else {\n    thresholdState = 1;  // Outside threshold range (triggered)\n  }\n\n  // Format data for serial plotter\n  // Using the format: AccelZ, ThresholdMin, ThresholdMax, ThresholdState\n  Serial.print(\"accelZ:\");\n  Serial.print(accelZ);\n  Serial.print(\",\");\n  Serial.print(\"T_MIN:\");\n  Serial.print(Z_THRESHOLD_MIN);\n  Serial.print(\",\");\n  Serial.print(\"T_MAX:\");\n  Serial.print(Z_THRESHOLD_MAX);\n  Serial.print(\",\");\n  Serial.print(\"State:\");\n  Serial.println(thresholdState * 10);  // Multiply by 10 to make it more visible in the plot\n}\n\nvoid loop() {\n  unsigned long currentTime = millis();\n\n  // Sample data at specified interval\n  if (currentTime - lastSampleTime &gt;= SAMPLE_INTERVAL) {\n    sampleIMUData();\n    lastSampleTime = currentTime;\n  }\n}\n</code></pre> <p></p> <p>This code will take the Z-Axis (tinyCore Face side) and create a Threshold: <code>Z_THRESHOLD_MIN</code> and <code>Z_THRESHOLD_MAX</code> as well as tracking it using a <code>thresholdState</code> . You can see this on the graph, as we move the Z-axis (in blue), when we move outside of the lower and upper bound, our State will trigger. Here\u2019s what that looks like measuring the device on a door:</p> Placement Hinge Edge Handle Edge Times Done 10 10 Times Detected 4 13"},{"location":"deep-dive/imu/#filtering","title":"Filtering:","text":"<p>Low-pass</p> <p>High-pass</p> <p>Band-pass</p> <p>Kalman:</p> <pre><code>#include &lt;tinyCore_LSM6DS3TRC.h&gt;\n#include &lt;SimpleKalmanFilter.h&gt;\n\ntinyCore_LSM6DS3TRC lsm6ds3trc;\nunsigned long lastSampleTime = 0;\nconst unsigned long SAMPLE_INTERVAL = 25; // Sample every 25ms\n\n// Z-axis threshold parameters (in m/s^2)\nfloat Z_THRESHOLD_MIN = -5.0;  // Minimum threshold \nfloat Z_THRESHOLD_MAX = 5.0;   // Maximum threshold\nint thresholdState = 0;        // Current threshold state (0 or 1)\n\n// SimpleKalmanFilter parameters (e_mea, e_est, q)\n// e_mea: Measurement uncertainty/noise\n// e_est: Estimation uncertainty\n// q: Process noise/variance\nSimpleKalmanFilter simpleKalmanFilter(1.0, 0.1, 0.01);\nfloat filteredAccelZ = 0.0;\n\nvoid setup() {\n  Serial.begin(115200);\n  /* while (!Serial) {\n    delay(10);\n  }*/\n\n  // Initialize IMU-related pins\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  // Initialize I2C\n  Wire.begin(3, 4);\n  delay(100);\n\n  Serial.println(\"Scanning for I2C devices...\");\n  for (byte address = 1; address &lt; 127; address++) {\n    Wire.beginTransmission(address);\n    byte error = Wire.endTransmission();\n    if (error == 0) {\n      Serial.print(\"I2C device found at address 0x\");\n      if (address &lt; 16) {\n        Serial.print(\"0\");\n      }\n      Serial.println(address, HEX);\n\n      // If this is our LSM6DS3TR-C address, try reading WHO_AM_I register\n      if (address == 0x6A) {\n        Wire.beginTransmission(0x6A);\n        Wire.write(0x0F); // WHO_AM_I register address\n        Wire.endTransmission(false);\n        Wire.requestFrom(0x6A, 1);\n        if (Wire.available()) {\n          byte whoAmI = Wire.read();\n          Serial.print(\"WHO_AM_I register value: 0x\");\n          Serial.println(whoAmI, HEX); // Should be 0x6A for LSM6DS3TR-C\n        }\n      }\n    }\n  }\n\n  Serial.println(\"Attempting to initialize LSM6DS3TR-C...\");\n  if (!lsm6ds3trc.begin_I2C()) {\n    Serial.println(\"Failed to find LSM6DS3TR-C chip\");\n    Serial.println(\"Check your wiring!\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  Serial.println(\"LSM6DS3TR-C Found!\");\n\n  // Configure IMU settings\n  lsm6ds3trc.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);\n  lsm6ds3trc.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS);\n  lsm6ds3trc.setAccelDataRate(LSM6DS_RATE_104_HZ);\n  lsm6ds3trc.setGyroDataRate(LSM6DS_RATE_104_HZ);\n\n  // Print labels for Serial Plotter\n  Serial.println(\"RawAccelZ:FilteredAccelZ:ThresholdMin:ThresholdMax:ThresholdState\");\n}\n\nvoid sampleIMUData() {\n  sensors_event_t accel;\n  sensors_event_t gyro;\n  sensors_event_t temp;\n\n  lsm6ds3trc.getEvent(&amp;accel, &amp;gyro, &amp;temp);\n\n  // Get Z-axis acceleration\n  float rawAccelZ = accel.acceleration.z;\n\n  // Apply SimpleKalmanFilter to smooth the data\n  filteredAccelZ = simpleKalmanFilter.updateEstimate(rawAccelZ);\n\n  // Determine threshold state based on filtered data (1 if outside thresholds, 0 if inside)\n  if (filteredAccelZ &gt;= Z_THRESHOLD_MIN &amp;&amp; filteredAccelZ &lt;= Z_THRESHOLD_MAX) {\n    thresholdState = 0;  // Within threshold range (not triggered)\n  } else {\n    thresholdState = 1;  // Outside threshold range (triggered)\n  }\n\n  // Format data for serial plotter\n  // Using the format: RawAccelZ, FilteredAccelZ, ThresholdMin, ThresholdMax, ThresholdState\n  Serial.print(rawAccelZ);\n  Serial.print(\",\");\n  Serial.print(filteredAccelZ);\n  Serial.print(\",\");\n  Serial.print(Z_THRESHOLD_MIN);\n  Serial.print(\",\");\n  Serial.print(Z_THRESHOLD_MAX);\n  Serial.print(\",\");\n  Serial.println(thresholdState * 10);  // Multiply by 10 to make it more visible in the plot\n}\n\nvoid loop() {\n  unsigned long currentTime = millis();\n\n  // Sample data at specified interval\n  if (currentTime - lastSampleTime &gt;= SAMPLE_INTERVAL) {\n    sampleIMUData();\n    lastSampleTime = currentTime;\n  }\n}\n</code></pre>"},{"location":"get-started/","title":"Get Started","text":""},{"location":"get-started/#so-you-bought-a-tinycore","title":"So you bought a tinyCore...","text":"<p>First off, Congratulations (and Thank You!)</p> <p>You're well on your way to building Awesome Things\u2122!</p> <p>But before you can do that, we need to setup some stuff.</p> <p>That's what this series is for. By the end of it you'll have a full assembled tinyCore, a setup development environment, and a working demo project, the Motion Logger!</p> <p>Let's dive in!</p>"},{"location":"get-started/arduino-ide/","title":"Setup the Arduino IDE","text":"<p>Created: February 15, 2025 9:32 PM Tags: Arduino, IMU Owner: Kickass Support</p>"},{"location":"get-started/arduino-ide/#1-software-and-prerequisites","title":"1. Software and Prerequisites","text":"<ul> <li>**Arduino IDE 1.6.4 or later**</li> <li>Working internet connection</li> </ul>"},{"location":"get-started/arduino-ide/#2-installation-steps","title":"2. Installation Steps","text":"<ol> <li>First, we need to download the Arduino IDE, which can be done from the\u00a0Arduino Software page.</li> <li>Install the Arduino IDE on your local machine.</li> <li>Open the Arduino IDE.</li> <li> <p>Navigate to Preferences     \u25e6 File &gt; Preferences (Windows/Linux)     \u25e6 Arduino &gt; Preferences (macOS)</p> <p></p> </li> <li> <p>Add Custom Board Manager URL     \u25e6 In \"Additional Board Manager URLs\" field, paste:\u00a0<code>https://raw.githubusercontent.com/Mister-Industries/arduino-board-index/refs/heads/main/package_tiny_core_index.json</code>     \u25e6 For multiple URLs, separate with commas</p> </li> </ol> <p></p> <ol> <li> <p>Open Board Manager     \u25e6 Tools &gt; Board &gt; Boards Manager</p> <p>(Or press the Boards Manager Icon on the left menu:) </p> <p></p> </li> <li> <p>Install ESP32 Boards/Tools     \u25e6 Search for\u00a0<code>esp32</code>     \u25e6 Select\u00a0<code>esp32</code>\u00a0package (v3.1.1) by Espressif     \u25e6 Click \"Install\"</p> <p></p> </li> <li> <p>Install iotaCore Custom Board     \u25e6 Search for\u00a0<code>tinyCore</code>     \u25e6 Select\u00a0<code>tinyCore ESP32 Boards</code>\u00a0package (v2.0.0) by MR.INDUSTRIES     \u25e6 Click \"Install\"</p> <p></p> </li> <li> <p>Plug in your tinyCore via the included USB-C Cable!</p> </li> <li>Under the devices tab, you should see a new device appear. Click <code>Select other board and port...</code></li> </ol> <p></p> <ol> <li>Search \u201ctinyCore\u201d and select <code>tinyCore ESP32-S3 No PSRAM</code> and click on the COM Port of the new device. Click OK.</li> </ol> <p></p> <ol> <li>Now, open the Blink Example by navigating to <code>File -&gt; Examples -&gt; 01.Basics -&gt; Blink</code></li> </ol> <p></p> <ol> <li> <p>Under <code>Tools</code>, make sure that:</p> <ul> <li>Upload Mode is set to\u00a0<code>UART0 / Hardware CDC</code></li> <li>USB Mode is set to\u00a0<code>Hardware CDC and JTAG</code></li> </ul> <p></p> </li> <li> <p>Click Upload!</p> <p>The code should compile and you should see the device flash and hard reset. </p> <p></p> <p>The \u201cSIG\u201d LED should now be blinking once every second!</p> <p></p> </li> <li> <p>Congrats! You\u2019re ready to start building! - Check out our IMU example</p> </li> </ol>"},{"location":"get-started/arduino-ide/#3-troubleshooting","title":"3. Troubleshooting","text":"<p>\u2022 Verify URL is correct and accessible</p> <p>\u2022 Check internet connection</p> <p>\u2022 Restart Arduino IDE if installation fails</p> <p>\u2022 Ensure you have the latest Arduino IDE version</p> <p>Having trouble?</p> <p>Send us an email at\u00a0support@mr.industries\u00a0or join our\u00a0Discord\u00a0for help!</p>"},{"location":"get-started/imu/","title":"Setting up the IMU","text":"<p>Created: February 18, 2025 8:20 PM Owner: Geoff McIntyre</p> <p>Are you skipping ahead?</p> <p>Make sure you have already installed the custom tinyCore board library and setup your Arduino IDE using the previous tutorial!</p> <p>In this tutorial, we will walk through how to use the built-in IMU on the tinyCore V2.0, using the Arduino IDE. At this point, you should have already installed the custom board library and tested flashing code with an example program (e.g. Blink).</p>"},{"location":"get-started/imu/#1-install-the-libraries","title":"1. Install the libraries","text":"<p>The IMU used on the chip is the LSM6DSOX, which Adafruit already made a wonderful library for: Adafruit_LSM6DS</p> <p>You can either install it manually, or click on the Library Manager icon in Arduino IDE:</p> <p></p> <p>Then search \u201cAdafruit_LSM6DS\u201d and click <code>INSTALL</code></p> <p></p> <p>FOR LEGACY (iotaCore) BOARDS ONLY:</p> <p>Legacy boards (labeled \"iotaCore\" on the back silkscreen) utilize an older LSM6DS3TRC IMU chip. These chips were manufactured with an I2C error, appearing at address 0x69 (instead of the 0x6A that Adafruit LSM6DS3 sensors normally use). To account for this, you will need to install our custom IMU library.</p> <p>After installing the Adafruit Library from the previous step, navigate to the folder it installed to. Usually this can be found in <code>Documents \u2192 Arduino \u2192 libraries \u2192 Adafruit LSM6DS</code></p> <p>Now, Download our custom tinyCore IMU libraries, and add them into this directory.</p> <p>tinyCore_LSM6DS3TRC.cpp</p> <p>tinyCore_LSM6DS3TRC.h</p> <p></p>"},{"location":"get-started/imu/#2-open-the-arduino-example","title":"2. Open the Arduino Example","text":"<p>Our IMU example demonstrates how to initialize the IMU and view it\u2019s data graphed out via the Serial Plotter in Arduino. To try it out, download or copy the example program below:</p> <p>IMU-Serial-Plotter.ino</p> ArduinoLegacy (iotaCore) <pre><code>#include &lt;Adafruit_LSM6DSOX.h&gt;\n\nAdafruit_LSM6DSOX lsm6dsox;\nunsigned long lastSampleTime = 0;\nconst unsigned long SAMPLE_INTERVAL = 25; // Sample every 25ms\n\nvoid setup() {\n  Serial.begin(115200);\n  /* while (!Serial) {\n    delay(10);\n  }*/\n\n  // Initialize IMU-related pins\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  // Initialize I2C\n  Wire.begin(3, 4);\n  delay(100);\n\n  Serial.println(\"Scanning for I2C devices...\");\n  for (byte address = 1; address &lt; 127; address++) {\n    Wire.beginTransmission(address);\n    byte error = Wire.endTransmission();\n    if (error == 0) {\n      Serial.print(\"I2C device found at address 0x\");\n      if (address &lt; 16) {\n        Serial.print(\"0\");\n      }\n      Serial.println(address, HEX);\n\n      // If this is our LSM6DSOX address, try reading WHO_AM_I register\n      if (address == 0x6A || address == 0x6B) {\n        Wire.beginTransmission(address);\n        Wire.write(0x0F);  // WHO_AM_I register address\n        Wire.endTransmission(false);\n        Wire.requestFrom(address, 1);\n        if (Wire.available()) {\n          byte whoAmI = Wire.read();\n          Serial.print(\"WHO_AM_I register value: 0x\");\n          Serial.println(whoAmI, HEX);\n          // Should be 0x6C for LSM6DSOX\n        }\n      }\n    }\n  }\n\n  Serial.println(\"Attempting to initialize LSM6DSOX...\");\n  if (!lsm6dsox.begin_I2C()) {\n    Serial.println(\"Failed to find LSM6DSOX chip\");\n    Serial.println(\"Check your wiring!\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  Serial.println(\"LSM6DSOX Found!\");\n\n  // Configure IMU settings\n  lsm6dsox.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);\n  lsm6dsox.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS);\n  lsm6dsox.setAccelDataRate(LSM6DS_RATE_104_HZ);\n  lsm6dsox.setGyroDataRate(LSM6DS_RATE_104_HZ);\n\n  // Print labels for Serial Plotter\n  Serial.println(\"AccelX:AccelY:AccelZ:GyroX:GyroY:GyroZ:Temp\");\n}\n\nvoid sampleIMUData() {\n  sensors_event_t accel;\n  sensors_event_t gyro;\n  sensors_event_t temp;\n  lsm6dsox.getEvent(&amp;accel, &amp;gyro, &amp;temp);\n\n  // Format data for serial plotter (label:value:label:value format)\n  Serial.print(\"AccelX:\");\n  Serial.print(accel.acceleration.x);\n  Serial.print(\",\");\n  Serial.print(\"AccelY:\");\n  Serial.print(accel.acceleration.y);\n  Serial.print(\",\");\n  Serial.print(\"AccelZ:\");\n  Serial.print(accel.acceleration.z);\n  Serial.print(\",\");\n  Serial.print(\"GyroX:\");\n  Serial.print(gyro.gyro.x);\n  Serial.print(\",\");\n  Serial.print(\"GyroY:\");\n  Serial.print(gyro.gyro.y);\n  Serial.print(\",\");\n  Serial.print(\"GyroZ:\");\n  Serial.print(gyro.gyro.z);\n  Serial.print(\",\");\n  Serial.println(temp.temperature);\n}\n\nvoid loop() {\n  unsigned long currentTime = millis();\n\n  // Sample data at specified interval\n  if (currentTime - lastSampleTime &gt;= SAMPLE_INTERVAL) {\n    sampleIMUData();\n    lastSampleTime = currentTime;\n  }\n}\n</code></pre> <pre><code>#include &lt;tinyCore_LSM6DS3TRC.h&gt;\n\ntinyCore_LSM6DS3TRC lsm6ds3trc;\nunsigned long lastSampleTime = 0;\nconst unsigned long SAMPLE_INTERVAL = 25; // Sample every 25ms\n\nvoid setup() {\n  Serial.begin(115200);\n  /* while (!Serial) {\n    delay(10);\n  }*/\n\n  // Initialize IMU-related pins\n  pinMode(6, OUTPUT);\n  digitalWrite(6, HIGH);\n\n  // Initialize I2C\n  Wire.begin(3, 4);\n  delay(100);\n\n  Serial.println(\"Scanning for I2C devices...\");\n  for (byte address = 1; address &lt; 127; address++) {\n    Wire.beginTransmission(address);\n    byte error = Wire.endTransmission();\n    if (error == 0) {\n      Serial.print(\"I2C device found at address 0x\");\n      if (address &lt; 16) {\n        Serial.print(\"0\");\n      }\n      Serial.println(address, HEX);\n\n      // If this is our LSM6DS3TR-C address, try reading WHO_AM_I register\n      if (address == 0x6A) {\n        Wire.beginTransmission(0x6A);\n        Wire.write(0x0F);  // WHO_AM_I register address\n        Wire.endTransmission(false);\n        Wire.requestFrom(0x6A, 1);\n        if (Wire.available()) {\n          byte whoAmI = Wire.read();\n          Serial.print(\"WHO_AM_I register value: 0x\");\n          Serial.println(whoAmI, HEX);\n          // Should be 0x6A for LSM6DS3TR-C\n        }\n      }\n    }\n  }\n\n  Serial.println(\"Attempting to initialize LSM6DS3TR-C...\");\n  if (!lsm6ds3trc.begin_I2C()) {\n    Serial.println(\"Failed to find LSM6DS3TR-C chip\");\n    Serial.println(\"Check your wiring!\");\n    while (1) {\n      delay(10);\n    }\n  }\n\n  Serial.println(\"LSM6DS3TR-C Found!\");\n\n  // Configure IMU settings\n  lsm6ds3trc.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);\n  lsm6ds3trc.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS);\n  lsm6ds3trc.setAccelDataRate(LSM6DS_RATE_104_HZ);\n  lsm6ds3trc.setGyroDataRate(LSM6DS_RATE_104_HZ);\n\n  // Print labels for Serial Plotter\n  Serial.println(\"AccelX:AccelY:AccelZ:GyroX:GyroY:GyroZ:Temp\");\n}\n\nvoid sampleIMUData() {\n  sensors_event_t accel;\n  sensors_event_t gyro;\n  sensors_event_t temp;\n  lsm6ds3trc.getEvent(&amp;accel, &amp;gyro, &amp;temp);\n\n  // Format data for serial plotter (label:value:label:value format)\n  Serial.print(\"AccelX:\");\n  Serial.print(accel.acceleration.x);\n  Serial.print(\",\");\n  Serial.print(\"AccelY:\");\n  Serial.print(accel.acceleration.y);\n  Serial.print(\",\");\n  Serial.print(\"AccelZ:\");\n  Serial.print(accel.acceleration.z);\n  Serial.print(\",\");\n  Serial.print(\"GyroX:\");\n  Serial.print(gyro.gyro.x);\n  Serial.print(\",\");\n  Serial.print(\"GyroY:\");\n  Serial.print(gyro.gyro.y);\n  Serial.print(\",\");\n  Serial.print(\"GyroZ:\");\n  Serial.print(gyro.gyro.z);\n  Serial.print(\",\");\n  Serial.println(temp.temperature);\n}\n\nvoid loop() {\n  unsigned long currentTime = millis();\n\n  // Sample data at specified interval\n  if (currentTime - lastSampleTime &gt;= SAMPLE_INTERVAL) {\n    sampleIMUData();\n    lastSampleTime = currentTime;\n  }\n}\n</code></pre>"},{"location":"get-started/imu/#3-flash-the-tinycore","title":"3. Flash the tinyCore","text":"<p>Once you have the program opened in the Arduino IDE, and have connected your tinyCore via USB, it\u2019s time to flash.</p> <p>First, click the Board dropdown and <code>\u201cSelect other board and port\u2026\u201d</code></p> <p></p> <p>Select the correct board and COM Port of the device. Click <code>OK</code></p> <p></p> <p>Now click the <code>Upload</code> icon, and wait for the board to reboot.</p> <p></p> <p></p>"},{"location":"get-started/imu/#4-open-the-serial-plotter","title":"4. Open the Serial Plotter","text":"<p>The board should now be running the plotting program. Click the <code>Serial Plotter</code> icon in the top right corner of the IDE.</p> <p></p> <p>Ensure that you are set to the <code>115200 baud</code> bitrate (located in the bottom right corner of the IDE) </p> <p>You should now see several lines on the screen, color-coded and labeled with their variable type:</p> <p></p> <p>If your tinyCore is sitting up-right on a flat surface, you should see the third line (AccelZ) hovering around 9.81m/s. This is the acceleration due to gravity!</p> <p>Now, if you start shaking the device, you will also see it\u2019s movements, both accelerations and rotational movement in all six axes!</p> <p></p> <p>Try drawing circles in the air in different orientations, and see what shapes you can measure! Here\u2019s my result:</p> <p></p> Brain Teaser: Can you guess what frequency I was spinning the device at in the image above? Click for the Answer! <p>If we are sampling every 25ms, and there are ~13 points per rotation (one sine wave), then we know that it is 25 \u00d7 13 = 325ms per cycle. Converting this to a frequency by inverting it, we get 1/0.325, or ~3Hz!</p>"},{"location":"get-started/imu/#5-extra-notes","title":"5. Extra Notes","text":"<p>LSM6DS IMU Orientation:</p> <p></p> <p></p> <p>Learn more about improving our measurements via thresholding and Kalman filters in our IMU Deep Dive.</p> <p>Nice job, now let's move on to the next tutorial!</p> <p>Having trouble?</p> <p>Send us an email at\u00a0support@mr.industries\u00a0or join our\u00a0Discord\u00a0for help!</p>"},{"location":"get-started/motion-tracker/","title":"Building a Motion Tracker [DRAFT]","text":"<p>Nice job getting this far! Hopefully you've gotten all of the software installed, programmed the board, tested the IMU, and enjoyed your gummy bears. </p> <p>It's time for your first challenge! Using what you've learned so far, we're going to develop your first smart device, featuring everything special about the tinyCore. And we'll be learning something new, how to use the SD Card!</p> <p>Note</p> <p>If you want to learn about the SD Card in depth, check out the SD Card Tutorial in the Advanced section.</p> <p>We're going to create a motion tracker/data-logger. This is a device that will measure motion (IMU) and record it (SD Card), then wirelessly send it's data to a computer, which can be graphed out.</p> <p>This type of device is extremely useful in all sorts of scenarios. I've seen students use this to create a fitness rep counter, musical gloves, a FitBit for cows, a DIY step-counter, door entry alerts, and Physics I acceleration/velocity lab experiments. </p> <p>Before we show you the code, let's talk about architecture, how does this system actually work? What would it take to build this system with an industry standard like the Adafruit Feather?</p> <pre><code>flowchart TD\n    BATT[LiPo Battery - External] \n    COMP[Computer/Host - External]\n    ROUTER[WiFi Router - External] \n    SDCARD[Micro SD Card]\n\n    subgraph TINYCORE[tinyCore Integrated Board]\n        USB[USB-C Port]\n        CC[Charge Controller]\n        POWER[3.3V Power Rail]\n        ESP[ESP32S3 Main Processor]\n        IMU[LSM6DSOX IMU Integrated]\n        SDSLOT[SD Card Slot]\n        WIFI[WiFi Module]\n        BLE[Bluetooth LE]\n\n        USB --&gt; CC\n        CC --&gt; POWER\n        POWER --&gt; ESP\n        ESP --&gt; IMU\n        ESP --&gt; SDSLOT\n        ESP --&gt; WIFI\n        ESP --&gt; BLE\n    end\n\n    BATT --&gt; CC\n    USB --&gt; COMP\n    WIFI --&gt; ROUTER\n    ROUTER --&gt; COMP\n    BLE --&gt; COMP\n    SDCARD --&gt; SDSLOT</code></pre> <p>This is where the beauty of the tinyCore's integration comes in. Normally, you would need to purchase breakouts of an: - ESP32-S3 - LiPo Battery Power Management - Micro SD-Card - LSM6DSOX IMU</p> <p>Then you would spend a few hours wiring everything together, hopefully making no mistakes, and voila! (Oh wait, you still need code!)</p> <p>Instead, the tinyCore has everything you need, all in one place. </p> <p>Now that we've gone over the hardware architecture, let's talk about the software architecture. It will look something like this:</p> <pre><code>flowchart LR\n    %% Data Collection\n    START([Device Powers On]) --&gt; INIT[Initialize Sensors]\n    INIT --&gt; CALIB[Calibrate IMU]\n    CALIB --&gt; LOOP{Main Loop}\n\n    %% Sensor Reading\n    LOOP --&gt; READ[Read IMU Data&lt;br/&gt;Accelerometer XYZ&lt;br/&gt;Gyroscope XYZ]\n    READ --&gt; PROC[Process Data&lt;br/&gt;Apply Filters&lt;br/&gt;Calculate Motion Metrics]\n\n    %% Data Storage Decision\n    PROC --&gt; STORE{Storage Mode?}\n    STORE --&gt;|Local Logging| SD_WRITE[Write to SD Card&lt;br/&gt;Timestamp + Data]\n    STORE --&gt;|Real-time Stream| WIRELESS[Send via WiFi/BLE]\n    STORE --&gt;|Both| SD_WRITE\n    STORE --&gt;|Both| WIRELESS\n\n    %% Continue Loop\n    SD_WRITE --&gt; DELAY[Delay/Sleep]\n    WIRELESS --&gt; DELAY\n    DELAY --&gt; LOOP\n\n    %% External Data Access\n    SD_WRITE -.-&gt; USB_READ[USB Data Download]\n    WIRELESS -.-&gt; ANALYSIS[Real-time Analysis&lt;br/&gt;on Computer]\n\n    %% Styling\n    classDef start fill:#4caf50,stroke:#2e7d32,stroke-width:2px\n    classDef process fill:#2196f3,stroke:#1565c0,stroke-width:2px\n    classDef decision fill:#ff9800,stroke:#ef6c00,stroke-width:2px\n    classDef output fill:#9c27b0,stroke:#6a1b9a,stroke-width:2px\n\n    class START,INIT,CALIB start\n    class READ,PROC,DELAY process\n    class LOOP,STORE decision\n    class SD_WRITE,WIRELESS,USB_READ,ANALYSIS output</code></pre> <p>The datalogger has three main processes: 1. Setup or Initialization 2. Measure/Record Data 3. Transfer Data</p> <p>We'll be using UDP to dump the packets to an IP address, so it's easy for us to write a python program that can graph out the information in a useful way.</p> <p>We'll also be measuring data, but before we send it, we need to process it. This will look like a Kalman filter, and oversampling for noise removal.</p> <p>So here's the code:</p> <p>And here's the python program as well:</p> <p>Once we flash it, we should see this on our python UI!</p> <p>Try shaking the board around, and watch it rotate in real-time!</p> <p>Nice job. You've completed your very first project with tinyCore, and we hope it only took about 30 minutes!</p>"},{"location":"get-started/unboxing/","title":"Unboxing","text":""},{"location":"get-started/unboxing/#1-whats-inside","title":"1. What's Inside","text":"<p>Inside your tinyCore V2 Kit, you should find several things to help you get started:</p> <p></p> Label Item Quantity 1 tinyCore V2.0 Development Board 1 2 3D-Printed Multi-color Snap Enclosure 1 NP M3 Machine Screws (for Enclosure, don't lose these!) 2 3 Micro SD Card (4GB) 1 4 USB Micro SD Card Reader 1 5 STEMMA/QWIIC Cable Connector (100cm) 1 6 USB-C Programming Cable (1m) 1 7 Plastic Project Box (11.5x8.5x2.8cm) 1 NP Secret sweet treat! \ud83e\udd2b 1 <p>NP = Not Pictured</p>"},{"location":"get-started/unboxing/#2-preparing-the-headers-optional","title":"2. Preparing the Headers (Optional)","text":"<p>Warning</p> <p>As of June 2025, if you have selected pre-soldered headers during checkout, this step will not be necessary!</p> <p>Here's your first big challenge: Soldering the headers!</p> <p>Luckily they are \"key-ed\"<sup>1</sup> by number, so you can only </p> <p>We have three headers to solder, Two Female, and one Male (9-pins)</p> <p>The female headers look like this, and are for the left and right (Digital and Analog) pins. </p> <p>Make sure they are face up on your board, then flip over the board and solder.</p> <p>The male headers look like this and are for the bottom (Serial) pins. </p> <p>After soldering in the female headers, you can place in the male header pins, and solder these too. </p>"},{"location":"get-started/unboxing/#3-assembling-the-enclosure","title":"3. Assembling the Enclosure","text":"<p>Once the headers are soldered, we can put the PCB in the enclosure!</p> <p>First, gently open up the clamshell<sup>2</sup> body of the enclosure. Unclip the hinges and open up the shell. </p> <p></p> <p>Remove the screws, and place the PCB so that the screw holes line up with the holes in the enclosure. The solid plastic dot goes towards the top!</p> <p>Then replace and tighten the M3 Screws provided in your kit.</p> <p>Warning</p> <p>Do not overtighten the screws! Just make sure they are snug.</p> <p></p> <p>Once the PCB is fit correctly and tightened down, return the cover to it's original position, making sure that the headers align with the holes in the top.</p> <p></p> <p>Now your tinyCore is ready to use!</p> <ol> <li> <p>\"Key-ing\" is a mechanical term that describes when something is designed in a way that it will only fit one way. Think of house keys!\u00a0\u21a9</p> </li> <li> <p>Meaning two parts that fit together\u00a0\u21a9</p> </li> </ol>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/weeknotes/","title":"Weeknotes","text":""},{"location":"blog/category/devlog/","title":"Devlog","text":""},{"location":"blog/category/testing/","title":"Testing","text":""},{"location":"blog/category/libraries/","title":"Libraries","text":""},{"location":"blog/page/2/","title":"Blog","text":""}]}